<?xml version="1.0" encoding="utf-8" ?>
<root>
  <data name="Solution" xml:space="preserve">
    <value>
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.28307.1738
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "${NR}$.Framework", "${NR}$.Framework\${NR}$.Framework.csproj", "{${FrameworkProjectGuid}$}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "${NR}$.Models", "${NR}$.Models\${NR}$.Models.csproj", "{${ModelsProjectGuid}$}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "${NR}$.Repositories", "${NR}$.Repositories\${NR}$.Repositories.csproj", "{${RepositoriesProjectGuid}$}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "${NR}$.Services", "${NR}$.Services\${NR}$.Services.csproj", "{${ServicesProjectGuid}$}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "${NR}$.Debug", "${NR}$.Debug\${NR}$.Debug.csproj", "{${DebugProjectGuid}$}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{${FrameworkProjectGuid}$}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{${FrameworkProjectGuid}$}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{${FrameworkProjectGuid}$}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{${FrameworkProjectGuid}$}.Release|Any CPU.Build.0 = Release|Any CPU
		{${ModelsProjectGuid}$}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{${ModelsProjectGuid}$}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{${ModelsProjectGuid}$}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{${ModelsProjectGuid}$}.Release|Any CPU.Build.0 = Release|Any CPU
		{${RepositoriesProjectGuid}$}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{${RepositoriesProjectGuid}$}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{${RepositoriesProjectGuid}$}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{${RepositoriesProjectGuid}$}.Release|Any CPU.Build.0 = Release|Any CPU
		{${ServicesProjectGuid}$}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{${ServicesProjectGuid}$}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{${ServicesProjectGuid}$}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{${ServicesProjectGuid}$}.Release|Any CPU.Build.0 = Release|Any CPU
		{${DebugProjectGuid}$}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{${DebugProjectGuid}$}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{${DebugProjectGuid}$}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{${DebugProjectGuid}$}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {${SolutionGuid}$.}
	EndGlobalSection
EndGlobal
</value>
    <comment>${SLN}$\${SLN}$.sln</comment>
  </data>
  <data name="Framework_Lifetime_Scoped_cs" xml:space="preserve">
    <value>using System;
using System.Transactions;

namespace ${NR}$.Framework
{
    public class Scoped&lt;T&gt; where T : class, new()
    {
        private static readonly object _locker = new object();
        private static T _instance;
        public static T Instance
        {
            get
            {
                if (_instance == null)
                {
                    lock (_locker)
                    {
                        if (_instance == null)
                        {
                            _instance = new T();
                            if (Transaction.Current != null)
                            {
                                Transaction.Current.TransactionCompleted += delegate
                                {
                                    if (_instance is IDisposable disposable)
                                    {
                                        disposable.Dispose();
                                    }
                                    _instance = null;
                                };
                            }
                        }
                    }
                }
                return _instance;
            }
        }
    }
}</value>
    <comment>${SLN}$\${NR}$.Framework\Lifetime\Scoped.cs</comment>
  </data>
  <data name="Framework_Lifetime_Singleton_cs" xml:space="preserve">
    <value>using System;

namespace ${NR}$.Framework
{
    public class Singleton&lt;T&gt; where T : new()
    {
        private static Lazy&lt;T&gt; _singletonHolder = new Lazy&lt;T&gt;(() =&gt; new T(), true);
        private Singleton() { }
        public static T Instance =&gt; _singletonHolder.Value;
    }
}</value>
    <comment>${SLN}$\${NR}$.Framework\Lifetime\Singleton.cs</comment>
  </data>
  <data name="Framework_Properties_AssemblyInfo_cs" xml:space="preserve">
    <value>using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// 有关程序集的一般信息由以下
// 控制。更改这些特性值可修改
// 与程序集关联的信息。
[assembly: AssemblyTitle("${NR}$.Framework")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("${NR}$.Framework")]
[assembly: AssemblyCopyright("Copyright ©  2022")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// 将 ComVisible 设置为 false 会使此程序集中的类型
//对 COM 组件不可见。如果需要从 COM 访问此程序集中的类型
//请将此类型的 ComVisible 特性设置为 true。
[assembly: ComVisible(false)]

// 如果此项目向 COM 公开，则下列 GUID 用于类型库的 ID
[assembly: Guid("${FrameworkProjectGuid}$")]

// 程序集的版本信息由下列四个值组成: 
//
//      主版本
//      次版本
//      生成号
//      修订号
//
// 可以指定所有值，也可以使用以下所示的 "*" 预置版本号和修订号
//通过使用 "*"，如下所示:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]</value>
    <comment>${SLN}$\${NR}$.Framework\Properties\AssemblyInfo.cs</comment>
  </data>
  <data name="Framework_RabbitMQ_Client_Consts_ArgumentKeys_cs" xml:space="preserve">
    <value>using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace RabbitMQ.Client
{
    /// &lt;summary&gt;
    /// 参数键
    /// &lt;/summary&gt;
    public class ArgumentKeys
    {
        /// &lt;summary&gt;
        /// 队列类型
        /// &lt;/summary&gt;
        public const string QueueType = "x-queue-type";

        /// &lt;summary&gt;
        /// 死信交换机
        /// &lt;/summary&gt;
        public const string DeadLetterExchange = "x-dead-letter-exchange";

        /// &lt;summary&gt;
        /// 消息存活时长
        /// &lt;/summary&gt;
        public const string TimeToLive = "x-message-ttl";
    }
}</value>
    <comment>${SLN}$\${NR}$.Framework\RabbitMQ.Client\Consts\ArgumentKeys.cs</comment>
  </data>
  <data name="Framework_RabbitMQ_Client_Consts_ExchangeModes_cs" xml:space="preserve">
    <value>using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace RabbitMQ.Client
{
    /// &lt;summary&gt;
    /// 交换模式
    /// &lt;/summary&gt;
    public enum ExchangeModes
    {
        /// &lt;summary&gt;
        /// 正常
        /// &lt;/summary&gt;
        Normal = 0,

        /// &lt;summary&gt;
        /// 死信交换模式
        /// &lt;/summary&gt;
        DLX = 1,
    }
}</value>
    <comment>${SLN}$\${NR}$.Framework\RabbitMQ.Client\Consts\ExchangeModes.cs</comment>
  </data>
  <data name="Framework_RabbitMQ_Client_Consts_ExchangeTypes_cs" xml:space="preserve">
    <value>namespace RabbitMQ.Client
{
    /// &lt;summary&gt;
    /// 交换机类型
    /// &lt;/summary&gt;
    public class ExchangeTypes
    {
        /// &lt;summary&gt;
        /// 将消息路由到那些binding key与routing key完全匹配的队列中
        /// &lt;/summary&gt;
        public const string Direct = "direct";
        /// &lt;summary&gt;
        /// 将消息路由到所有绑定的队列中
        /// &lt;/summary&gt;
        public const string Fanout = "fanout";
        /// &lt;summary&gt;
        /// 将消息路由到具有相同header arguments的队列中
        /// &lt;/summary&gt;
        public const string Headers = "headers";
        /// &lt;summary&gt;
        /// 将消息路由到binding key与routing key模式匹配的队列中 (通配符: '*', '#', 其中'*'表示匹配一个单词, '#'则表示匹配没有或者多个单词)
        /// &lt;/summary&gt;
        public const string Topic = "topic";
    }
}</value>
    <comment>${SLN}$\${NR}$.Framework\RabbitMQ.Client\Consts\ExchangeTypes.cs</comment>
  </data>
  <data name="Framework_RabbitMQ_Client_Consts_QueueTypes_cs" xml:space="preserve">
    <value>namespace RabbitMQ.Client
{
    /// &lt;summary&gt;
    /// 队列类型
    /// &lt;/summary&gt;
    public class QueueTypes
    {
        /// &lt;summary&gt;
        /// 默认队列
        /// &lt;/summary&gt;
        public const string Classic = "classic";

        /// &lt;summary&gt;
        /// 仲裁队列
        /// &lt;para&gt;仲裁队列是镜像队列(又称为HA队列)的替代方案，该队列把数据安全作为首要目标，在3.8.0版本可以使用。声明仲裁队列和声明普通队列方法一样，只需要把x-queue-type设置为quorum即可。&lt;/para&gt;
        /// &lt;/summary&gt;
        public const string Quorum = "quorum";
    }
}</value>
    <comment>${SLN}$\${NR}$.Framework\RabbitMQ.Client\Consts\QueueTypes.cs</comment>
  </data>
  <data name="Framework_RabbitMQ_Client_Message_cs" xml:space="preserve">
    <value>using Newtonsoft.Json;
using RabbitMQ.Client.Events;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace RabbitMQ.Client
{
    public class Message : IMessage
    {
        protected string _content;
        protected byte[] _body;

        public ulong DeliveryTag { get; set; }
        public string ReplyTo { get; set; }
        public string CorrelationId { get; set; }
        public string Content =&gt; _content ?? (_content = Encoding.UTF8.GetString(Body));
        [JsonIgnore]
        public byte[] Body =&gt; _body ?? (_body = Encoding.UTF8.GetBytes(Content));

        public Message()
        {

        }

        public Message(string content, string correlationId = null)
        {
            _content = content;
            CorrelationId = correlationId ?? Guid.NewGuid().ToString("N");
        }

        public Message(byte[] body, ulong deliveryTag, IBasicProperties props)
        {
            _body = body;
            _content = Encoding.UTF8.GetString(_body);
            DeliveryTag = deliveryTag;
            ReplyTo = props?.ReplyTo;
            CorrelationId = props?.CorrelationId;
        }

        public Message(BasicDeliverEventArgs args) : this(args.Body.ToArray(), args.DeliveryTag, args.BasicProperties)
        {
        }

        public Message(BasicGetResult result) : this(result.Body.ToArray(), result.DeliveryTag, result.BasicProperties)
        {
        }

        public void Backup(string path)
        {
            string directory = Path.GetDirectoryName(path);
            if (!Directory.Exists(directory))
            {
                Directory.CreateDirectory(directory);
            }
            lock (string.Intern(path))
            {
                File.AppendAllLines(path, new string[] { JsonConvert.SerializeObject(this) });
            }
        }

        public IMessage&lt;T&gt; Cast&lt;T&gt;()
        {
            return new Message&lt;T&gt;(Content, DeliveryTag, ReplyTo, CorrelationId);
        }

        public override string ToString() =&gt; Content;
    }
}</value>
    <comment>${SLN}$\${NR}$.Framework\RabbitMQ.Client\Message.cs</comment>
  </data>
  <data name="Framework_RabbitMQ_Client_Message_1_cs" xml:space="preserve">
    <value>using Newtonsoft.Json;
using RabbitMQ.Client.Events;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace RabbitMQ.Client
{
    public class Message&lt;T&gt; : Message, IMessage&lt;T&gt;
    {
        private static readonly JsonSerializerSettings _jsonSerializerSettings = new JsonSerializerSettings { NullValueHandling = NullValueHandling.Ignore };

        protected T _value;

        [JsonIgnore]
        public T Value =&gt; Equals(_value, default(T)) ? (_value = JsonConvert.DeserializeObject&lt;T&gt;(_content)) : _value;

        public Message(T value, string correlationId = null)
        {
            _value = value;
            _content = JsonConvert.SerializeObject(Value, _jsonSerializerSettings);
            CorrelationId = correlationId ?? Guid.NewGuid().ToString("N");
        }

        public Message(byte[] body, ulong deliveryTag, IBasicProperties props) : base(body, deliveryTag, props)
        {
            _value = JsonConvert.DeserializeObject&lt;T&gt;(_content);
        }

        public Message(string content, ulong deliveryTag, string replyTo, string correlationId)
        {
            _content = content;
            DeliveryTag = deliveryTag;
            ReplyTo = replyTo;
            CorrelationId = correlationId;
        }

        public Message(BasicDeliverEventArgs args) : this(args.Body.ToArray(), args.DeliveryTag, args.BasicProperties)
        {
        }

        public Message(BasicGetResult result) : this(result.Body.ToArray(), result.DeliveryTag, result.BasicProperties)
        {
        }

    }
}</value>
    <comment>${SLN}$\${NR}$.Framework\RabbitMQ.Client\Message`1.cs</comment>
  </data>
  <data name="Framework_RabbitMQ_Client_MessageConsumer_cs" xml:space="preserve">
    <value>using Newtonsoft.Json;
using RabbitMQ.Client.Events;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace RabbitMQ.Client
{
    public class MessageConsumer : IMessageConsumer
    {
        public const int MaxRetryCount = 3;
        public const string FailedFolder = "consume_failed";

        protected readonly IDictionary&lt;string, object&gt; _replyProducerMap;

        public event EventHandler Disposed;

        public IMqClient Client { get; }
        public IConnection Connection { get; }
        public IModel Channel { get; }
        public string RoutingKey { get; }
        public ExchangeModes ExchangeMode { get; }
        public string QueueType { get; }
        public uint Ttl { get; }

        public string BackupPath =&gt; Path.Combine(AppDomain.CurrentDomain.BaseDirectory, FailedFolder, DateTime.Today.ToString("yyyy-MM-dd"), $"{RoutingKey}.txt");
        public EventingBasicConsumer Consumer { get; }

        public MessageConsumer(IMqClient client, string routingKey, ExchangeModes exchangeMode = ExchangeModes.Normal, string queueType = null, uint ttl = 0)
        {
            _replyProducerMap = new Dictionary&lt;string, object&gt;();

            Client = client;
            RoutingKey = routingKey;
            ExchangeMode = exchangeMode;
            QueueType = queueType;
            Ttl = ttl;
            Connection = Client.CreateConnection();
            Channel = Connection.CreateModel();
            Client.SetRoute(Channel, RoutingKey, exchangeMode, queueType, ttl);
            if (Client.Fairly) Channel.BasicQos(0, 1, false);
            Consumer = new EventingBasicConsumer(Channel);
        }

        public void Subscribe(Action&lt;IMessage&gt; handler)
        {
            Subscribe(x =&gt; { handler(x); return true; });
        }

        public void Subscribe(Func&lt;IMessage, object&gt; handler)
        {
            Consumer.Received += (sender, e) =&gt;
            {
                bool success = false;
                object reply = null;
                IMessage message = null;
                try
                {
                    message = new Message(e);
                    reply = handler(message);
                    if (!string.IsNullOrEmpty(message.ReplyTo))
                    {
                        // 回发
                        IMessageProducer replyProducer = GetReplyProducer(message.ReplyTo);
                        replyProducer.Publish(reply.ToString(), message.CorrelationId);
                        success = true;
                    }
                    else
                    {
                        success = reply is bool result ? result : true;
                    }
                }
                catch (Exception ex)
                {
                    Trace.TraceError(ex.ToString());
                }
                if (success)
                {
                    // 消息确认 (销毁当前消息)
                    Channel.BasicAck(e.DeliveryTag, false);
                }
                else
                {
                    if (ExchangeMode == ExchangeModes.DLX)
                    {
                        long retryCount = GetRetryCount(e.BasicProperties.Headers); // 重试次数
                        if (retryCount &lt; MaxRetryCount) // 最大重试次数内 转发给 Retry 交换机
                        {
                            // 定义下一次投递的间隔时间 ms
                            long interval = (retryCount + 1) * 10 * 1000 /*每多重试一次 增加10秒*/;
                            e.BasicProperties.Expiration = interval.ToString();

                            // 将消息投递给 Retry 交换机 (会自动增加 death 次数)
                            Trace.TraceInformation("Retring...");
                            Channel.BasicPublish(Client.ExchangeRetry, e.RoutingKey, e.BasicProperties, e.Body);

                            // 消息确认 (销毁当前消息)
                            Channel.BasicAck(e.DeliveryTag, false);
                        }
                        else // 超过最大重试次数
                        {
                            // 消息拒绝 投递到死信交换机
                            Trace.TraceInformation($"Deliver to DLX[CorrelationId:{e.BasicProperties.CorrelationId}]");
                            Channel.BasicNack(e.DeliveryTag, false, false);

                            // 备份到本地
                            Trace.TraceInformation("Backup...");
                            message.Backup(BackupPath);
                        }
                    }
                    else
                    {
                        // 消息拒绝
                        Trace.TraceInformation($"Nack message[CorrelationId:{e.BasicProperties.CorrelationId}]");
                        Channel.BasicNack(e.DeliveryTag, false, false);

                        // 备份到本地
                        Trace.TraceInformation("Backup...");
                        message.Backup(BackupPath);
                    }
                }
            };
            Channel.BasicConsume(RoutingKey, false, Consumer);
        }

        private IMessageProducer GetReplyProducer(string replyTo)
        {
            if (_replyProducerMap.TryGetValue(replyTo, out object producer))
            {
                return producer as IMessageProducer;
            }
            IMessageProducer replyProducer = new MessageProducer(Client, replyTo);
            Disposed += delegate { replyProducer?.Dispose(); };
            lock (_replyProducerMap)
            {
                _replyProducerMap[replyTo] = replyProducer;
            }
            return replyProducer;
        }

        private long GetRetryCount(IDictionary&lt;string, object&gt; headers)
        {
            IDictionary&lt;string, object&gt; death = null;
            if (headers != null &amp;&amp; headers.ContainsKey("x-death"))
            {
                death = (headers["x-death"] as List&lt;object&gt;).FirstOrDefault() as IDictionary&lt;string, object&gt;;
            }
            return (long)(death?["count"] ?? 0L);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (disposing)
            {
                Channel?.Dispose();
                Connection?.Dispose();
                Disposed?.Invoke(this, EventArgs.Empty);
            }
        }

        public void Dispose()
        {
            Dispose(true);
        }

        ~MessageConsumer()
        {
            Dispose(false);
            GC.SuppressFinalize(this);
        }
    }
}</value>
    <comment>${SLN}$\${NR}$.Framework\RabbitMQ.Client\MessageConsumer.cs</comment>
  </data>
  <data name="Framework_csproj" xml:space="preserve">
    <value>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003"&gt;
  &lt;Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" /&gt;
  &lt;PropertyGroup&gt;
    &lt;Configuration Condition=" '$(Configuration)' == '' "&gt;Debug&lt;/Configuration&gt;
    &lt;Platform Condition=" '$(Platform)' == '' "&gt;AnyCPU&lt;/Platform&gt;
    &lt;ProjectGuid&gt;{${FrameworkProjectGuid}$}&lt;/ProjectGuid&gt;
    &lt;OutputType&gt;Library&lt;/OutputType&gt;
    &lt;AppDesignerFolder&gt;Properties&lt;/AppDesignerFolder&gt;
    &lt;RootNamespace&gt;${NR}$.Framework&lt;/RootNamespace&gt;
    &lt;AssemblyName&gt;${NR}$.Framework&lt;/AssemblyName&gt;
    &lt;TargetFrameworkVersion&gt;v4.6.1&lt;/TargetFrameworkVersion&gt;
    &lt;FileAlignment&gt;512&lt;/FileAlignment&gt;
    &lt;Deterministic&gt;true&lt;/Deterministic&gt;
    &lt;SccProjectName&gt;
    &lt;/SccProjectName&gt;
    &lt;SccLocalPath&gt;
    &lt;/SccLocalPath&gt;
    &lt;SccAuxPath&gt;
    &lt;/SccAuxPath&gt;
    &lt;SccProvider&gt;
    &lt;/SccProvider&gt;
  &lt;/PropertyGroup&gt;
  &lt;PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' "&gt;
    &lt;DebugSymbols&gt;true&lt;/DebugSymbols&gt;
    &lt;DebugType&gt;full&lt;/DebugType&gt;
    &lt;Optimize&gt;false&lt;/Optimize&gt;
    &lt;OutputPath&gt;bin\Debug\&lt;/OutputPath&gt;
    &lt;DefineConstants&gt;DEBUG;TRACE&lt;/DefineConstants&gt;
    &lt;ErrorReport&gt;prompt&lt;/ErrorReport&gt;
    &lt;WarningLevel&gt;4&lt;/WarningLevel&gt;
  &lt;/PropertyGroup&gt;
  &lt;PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' "&gt;
    &lt;DebugType&gt;pdbonly&lt;/DebugType&gt;
    &lt;Optimize&gt;true&lt;/Optimize&gt;
    &lt;OutputPath&gt;bin\Release\&lt;/OutputPath&gt;
    &lt;DefineConstants&gt;TRACE&lt;/DefineConstants&gt;
    &lt;ErrorReport&gt;prompt&lt;/ErrorReport&gt;
    &lt;WarningLevel&gt;4&lt;/WarningLevel&gt;
  &lt;/PropertyGroup&gt;
  &lt;ItemGroup&gt;
    &lt;Reference Include="Newtonsoft.Json, Version=13.0.0.0, Culture=neutral, PublicKeyToken=30ad4fe6b2a6aeed, processorArchitecture=MSIL"&gt;
      &lt;HintPath&gt;..\packages\Newtonsoft.Json.13.0.1\lib\net45\Newtonsoft.Json.dll&lt;/HintPath&gt;
    &lt;/Reference&gt;
    &lt;Reference Include="RabbitMQ.Client, Version=6.0.0.0, Culture=neutral, PublicKeyToken=89e7d7c5feba84ce, processorArchitecture=MSIL"&gt;
      &lt;HintPath&gt;..\packages\RabbitMQ.Client.6.4.0\lib\net461\RabbitMQ.Client.dll&lt;/HintPath&gt;
    &lt;/Reference&gt;
    &lt;Reference Include="System" /&gt;
    &lt;Reference Include="System.Buffers, Version=4.0.3.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL"&gt;
      &lt;HintPath&gt;..\packages\System.Buffers.4.5.1\lib\net461\System.Buffers.dll&lt;/HintPath&gt;
    &lt;/Reference&gt;
    &lt;Reference Include="System.Configuration" /&gt;
    &lt;Reference Include="System.Core" /&gt;
    &lt;Reference Include="System.Memory, Version=4.0.1.1, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL"&gt;
      &lt;HintPath&gt;..\packages\System.Memory.4.5.4\lib\net461\System.Memory.dll&lt;/HintPath&gt;
    &lt;/Reference&gt;
    &lt;Reference Include="System.Numerics" /&gt;
    &lt;Reference Include="System.Numerics.Vectors, Version=4.1.4.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL"&gt;
      &lt;HintPath&gt;..\packages\System.Numerics.Vectors.4.5.0\lib\net46\System.Numerics.Vectors.dll&lt;/HintPath&gt;
    &lt;/Reference&gt;
    &lt;Reference Include="System.Runtime.CompilerServices.Unsafe, Version=4.0.4.1, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL"&gt;
      &lt;HintPath&gt;..\packages\System.Runtime.CompilerServices.Unsafe.4.5.3\lib\net461\System.Runtime.CompilerServices.Unsafe.dll&lt;/HintPath&gt;
    &lt;/Reference&gt;
    &lt;Reference Include="System.Threading.Channels, Version=4.0.2.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL"&gt;
      &lt;HintPath&gt;..\packages\System.Threading.Channels.4.7.1\lib\net461\System.Threading.Channels.dll&lt;/HintPath&gt;
    &lt;/Reference&gt;
    &lt;Reference Include="System.Threading.Tasks.Extensions, Version=4.2.0.1, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL"&gt;
      &lt;HintPath&gt;..\packages\System.Threading.Tasks.Extensions.4.5.4\lib\net461\System.Threading.Tasks.Extensions.dll&lt;/HintPath&gt;
    &lt;/Reference&gt;
    &lt;Reference Include="System.Transactions" /&gt;
    &lt;Reference Include="System.Web" /&gt;
    &lt;Reference Include="System.Xml.Linq" /&gt;
    &lt;Reference Include="System.Data.DataSetExtensions" /&gt;
    &lt;Reference Include="Microsoft.CSharp" /&gt;
    &lt;Reference Include="System.Data" /&gt;
    &lt;Reference Include="System.Net.Http" /&gt;
    &lt;Reference Include="System.Xml" /&gt;
  &lt;/ItemGroup&gt;
  &lt;ItemGroup&gt;
    &lt;Compile Include="AppSettings.cs" /&gt;
    &lt;Compile Include="Clock\ClockDaemon.cs" /&gt;
    &lt;Compile Include="Clock\ClockJob.cs" /&gt;
    &lt;Compile Include="Clock\ClockSchedule.cs" /&gt;
    &lt;Compile Include="CurrentUser.cs" /&gt;
    &lt;Compile Include="Database.cs" /&gt;
    &lt;Compile Include="EnumerableExtensions.cs" /&gt;
    &lt;Compile Include="Lifetime\Scoped.cs" /&gt;
    &lt;Compile Include="Lifetime\Singleton.cs" /&gt;
    &lt;Compile Include="Properties\AssemblyInfo.cs" /&gt;
    &lt;Compile Include="RabbitMQ.Client\Consts\ArgumentKeys.cs" /&gt;
    &lt;Compile Include="RabbitMQ.Client\Consts\ExchangeModes.cs" /&gt;
    &lt;Compile Include="RabbitMQ.Client\Consts\ExchangeTypes.cs" /&gt;
    &lt;Compile Include="RabbitMQ.Client\Consts\QueueTypes.cs" /&gt;
    &lt;Compile Include="RabbitMQ.Client\Message.cs" /&gt;
    &lt;Compile Include="RabbitMQ.Client\MessageConsumer.cs" /&gt;
    &lt;Compile Include="RabbitMQ.Client\MessageConsumer`1.cs" /&gt;
    &lt;Compile Include="RabbitMQ.Client\MessageProducer.cs" /&gt;
    &lt;Compile Include="RabbitMQ.Client\MessageProducer`1.cs" /&gt;
    &lt;Compile Include="RabbitMQ.Client\MessageQueue.cs" /&gt;
    &lt;Compile Include="RabbitMQ.Client\MessageQueue`1.cs" /&gt;
    &lt;Compile Include="RabbitMQ.Client\Message`1.cs" /&gt;
    &lt;Compile Include="RabbitMQ.Client\MqClient.cs" /&gt;
    &lt;Compile Include="RabbitMQ.Client\RemoteProcedure.cs" /&gt;
    &lt;Compile Include="RabbitMQ.Client\RemoteProcedure`2.cs" /&gt;
    &lt;Compile Include="RabbitMQ.Client\Roles\IMessage.cs" /&gt;
    &lt;Compile Include="RabbitMQ.Client\Roles\IMessageConsumer.cs" /&gt;
    &lt;Compile Include="RabbitMQ.Client\Roles\IMessageConsumer`1.cs" /&gt;
    &lt;Compile Include="RabbitMQ.Client\Roles\IMessageProducer.cs" /&gt;
    &lt;Compile Include="RabbitMQ.Client\Roles\IMessageProducer`1.cs" /&gt;
    &lt;Compile Include="RabbitMQ.Client\Roles\IMessageQueue.cs" /&gt;
    &lt;Compile Include="RabbitMQ.Client\Roles\IMessageQueue`1.cs" /&gt;
    &lt;Compile Include="RabbitMQ.Client\Roles\IMessage`1.cs" /&gt;
    &lt;Compile Include="RabbitMQ.Client\Roles\IMqClient.cs" /&gt;
    &lt;Compile Include="RabbitMQ.Client\Roles\IRemoteProcedure.cs" /&gt;
    &lt;Compile Include="RabbitMQ.Client\Roles\IRemoteProcedure`2.cs" /&gt;
    &lt;Compile Include="System.Diagnostics\DailyErrorLogger.cs" /&gt;
    &lt;Compile Include="System.Diagnostics\DailyInfoLogger.cs" /&gt;
    &lt;Compile Include="System.Diagnostics\DailyLogger.cs" /&gt;
    &lt;Compile Include="System.Diagnostics\Logger.cs" /&gt;
  &lt;/ItemGroup&gt;
  &lt;ItemGroup&gt;
    &lt;None Include="app.config" /&gt;
    &lt;None Include="packages.config"&gt;
      &lt;SubType&gt;Designer&lt;/SubType&gt;
    &lt;/None&gt;
  &lt;/ItemGroup&gt;
  &lt;ItemGroup /&gt;
  &lt;Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" /&gt;
&lt;/Project&gt;</value>
    <comment>${SLN}$\${NR}$.Framework\${NR}$.Framework.csproj</comment>
  </data>
  <data name="Framework_RabbitMQ_Client_MessageConsumer_1_cs" xml:space="preserve">
    <value>using Newtonsoft.Json;
using RabbitMQ.Client.Events;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace RabbitMQ.Client
{
    public class MessageConsumer&lt;T&gt; : MessageConsumer, IMessageConsumer&lt;T&gt;
    {
        public MessageConsumer(IMqClient client, string routingKey, ExchangeModes exchangeMode = ExchangeModes.Normal, string queueType = null, uint ttl = 0)
            : base(client, routingKey, exchangeMode, queueType, ttl)
        {
        }

        public void Subscribe(Action&lt;IMessage&lt;T&gt;&gt; handler)
        {
            Subscribe(x =&gt; { handler(x); return true; });
        }

        public void Subscribe&lt;TReply&gt;(Func&lt;IMessage&lt;T&gt;, TReply&gt; handler)
        {
            base.Subscribe(x =&gt; handler(x.Cast&lt;T&gt;()));
        }
    }
}</value>
    <comment>${SLN}$\${NR}$.Framework\RabbitMQ.Client\MessageConsumer`1.cs</comment>
  </data>
  <data name="Framework_RabbitMQ_Client_MessageProducer_cs" xml:space="preserve">
    <value>using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;

namespace RabbitMQ.Client
{
    public class MessageProducer : IMessageProducer
    {
        public const int MaxRetryCount = 3;
        public const string FailedFolder = "publish_failed";

        private readonly List&lt;IMessage&gt; _msgList;
        private readonly Dictionary&lt;string, int&gt; _retryMap;
        private string _replyTo;

        public event EventHandler Disposed;
        public event Action&lt;string&gt; PublishSuccess;
        public event Action&lt;string&gt; PublishFailed;

        public IMqClient Client { get; }
        public IConnection Connection { get; }
        public IModel Channel { get; }
        public string RoutingKey { get; }
        public ExchangeModes ExchangeMode { get; }
        public string QueueType { get; }
        public uint Ttl { get; }

        public string BackupPath =&gt; Path.Combine(AppDomain.CurrentDomain.BaseDirectory, FailedFolder, DateTime.Today.ToString("yyyy-MM-dd"), $"{RoutingKey}.txt");

        public MessageProducer() { }

        public MessageProducer(IMqClient client, string routingKey, ExchangeModes exchangeMode = ExchangeModes.Normal, string queueType = null, uint ttl = 0)
        {
            _msgList = new List&lt;IMessage&gt;();
            _retryMap = new Dictionary&lt;string, int&gt;();

            Client = client;
            RoutingKey = routingKey;
            ExchangeMode = exchangeMode;
            QueueType = queueType;
            Ttl = ttl;
            Connection = Client.CreateConnection();
            Channel = Connection.CreateModel();
            Client.SetRoute(Channel, RoutingKey, exchangeMode, queueType, ttl);
            Channel.BasicAcks += Channel_BasicAcks;
            Channel.BasicNacks += Channel_BasicNacks;
            Channel.ConfirmSelect();
        }

        public IMessage Publish(string content, string correlationId = null)
        {
            IMessage message = new Message(content, correlationId);
            Publish(message);
            return message;
        }

        protected void Publish(IMessage message)
        {
            lock (_msgList)
            {
                _msgList.Add(message);
            }
            IBasicProperties props = Channel.CreateBasicProperties();
            {
                props.CorrelationId = message.CorrelationId;
                if (Client.Durable) props.Persistent = true;
                if (!string.IsNullOrEmpty(_replyTo)) props.ReplyTo = _replyTo;
            }
            message.DeliveryTag = Channel.NextPublishSeqNo;
            Channel.BasicPublish(Client.Exchange, RoutingKey, props, message.Body);
        }

        public IMessageProducer ReplyTo(Func&lt;IMessage, object&gt; callback, string replyTo = null)
        {
            IMessageConsumer consumer = null;
            Disposed += delegate { consumer?.Dispose(); };
            _replyTo = replyTo ?? $"r.{RoutingKey}";
            consumer = new MessageConsumer(Client, _replyTo, ExchangeMode, QueueType, Ttl);
            consumer.Subscribe(callback);
            return this;
        }

        public void WaitForConfirmsOrDie(TimeSpan timeout)
        {
            Channel.WaitForConfirmsOrDie(timeout);
        }

        /// &lt;summary&gt;
        /// 发布成功
        /// &lt;/summary&gt;
        /// &lt;param name="sender"&gt;&lt;/param&gt;
        /// &lt;param name="e"&gt;&lt;/param&gt;
        private void Channel_BasicAcks(object sender, Events.BasicAckEventArgs e)
        {
            if (e.Multiple)
            {
                Acks(x =&gt; x.DeliveryTag &lt;= e.DeliveryTag);
            }
            else
            {
                Acks(x =&gt; x.DeliveryTag == e.DeliveryTag);
            }
        }

        private void Acks(Func&lt;IMessage, bool&gt; predicate)
        {
            var msgs = _msgList.Where(predicate).ToList();
            foreach (var msg in msgs)
            {
                lock (_msgList)
                {
                    _msgList.Remove(msg); // 从列表中删除
                }
                PublishSuccess?.Invoke(msg.CorrelationId);
            }
        }

        /// &lt;summary&gt;
        /// 发布失败
        /// &lt;/summary&gt;
        /// &lt;param name="sender"&gt;&lt;/param&gt;
        /// &lt;param name="e"&gt;&lt;/param&gt;
        private void Channel_BasicNacks(object sender, Events.BasicNackEventArgs e)
        {
            Trace.TraceError($"Publish failed;\r\nDeliveryTag:{e.DeliveryTag};\r\nMultiple:{e.Multiple};");
            if (e.Multiple)
            {
                Nacks(x =&gt; x.DeliveryTag &lt;= e.DeliveryTag);
            }
            else
            {
                Nacks(x =&gt; x.DeliveryTag == e.DeliveryTag);
            }
        }

        private void Nacks(Func&lt;IMessage, bool&gt; predicate)
        {
            var msgs = _msgList.Where(predicate).ToList();
            foreach (var msg in msgs)
            {
                lock (_msgList)
                {
                    _msgList.Remove(msg); // 从列表中删除
                }
                if (!_retryMap.ContainsKey(msg.CorrelationId)) _retryMap[msg.CorrelationId] = 0;
                if (_retryMap[msg.CorrelationId] &lt; MaxRetryCount) // 最大重试次数内 
                {
                    Trace.TraceInformation("Retring...");
                    Publish(msg); // 重新发布
                    _retryMap[msg.CorrelationId]++;
                }
                else // 超过最大重试次数
                {
                    Trace.TraceInformation("Backup...");
                    msg.Backup(BackupPath); // 备份到本地
                    PublishFailed?.Invoke(msg.CorrelationId);
                }
            }
        }

        protected virtual void Dispose(bool disposing)
        {
            if (disposing)
            {
                Channel.Dispose();
                Connection.Dispose();
                Disposed?.Invoke(this, EventArgs.Empty);
            }
        }

        public void Dispose()
        {
            Dispose(true);
        }

        ~MessageProducer()
        {
            Dispose(false);
            GC.SuppressFinalize(this);
        }
    }
}</value>
    <comment>${SLN}$\${NR}$.Framework\RabbitMQ.Client\MessageProducer.cs</comment>
  </data>
  <data name="Framework_RabbitMQ_Client_MessageProducer_1_cs" xml:space="preserve">
    <value>using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;

namespace RabbitMQ.Client
{
    public class MessageProducer&lt;T&gt; : MessageProducer, IMessageProducer&lt;T&gt;
    {
        public MessageProducer(IMqClient client, string routingKey, ExchangeModes exchangeMode = ExchangeModes.Normal, string queueType = null, uint ttl = 0)
            : base(client, routingKey, exchangeMode, queueType, ttl)
        {
        }

        public IMessage&lt;T&gt; Publish(T value, string correlationId = null)
        {
            IMessage&lt;T&gt; message = new Message&lt;T&gt;(value, correlationId);
            base.Publish(message);
            return message;
        }

        public IMessageProducer&lt;T&gt; ReplyTo&lt;TReply&gt;(Func&lt;IMessage&lt;TReply&gt;, bool&gt; callback, string replyTo = null)
        {
            base.ReplyTo(x =&gt; callback(x.Cast&lt;TReply&gt;()), replyTo);
            return this;
        }
    }
}</value>
    <comment>${SLN}$\${NR}$.Framework\RabbitMQ.Client\MessageProducer`1.cs</comment>
  </data>
  <data name="Framework_RabbitMQ_Client_MessageQueue_cs" xml:space="preserve">
    <value>using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace RabbitMQ.Client
{
    public class MessageQueue : IMessageQueue
    {
        private MessageEnumerator _enumerator;

        public IMqClient Client { get; }
        public IConnection Connection { get; }
        public IModel Channel { get; }
        public string Queue { get; }

        public MessageQueue(IMqClient client, string queue, string queueType = null, uint ttl = 0)
        {
            Client = client;
            Connection = Client.CreateConnection();
            Channel = Connection.CreateModel();
            Queue = queue;
            Client.SetRoute(Channel, Queue, queueType: queueType, ttl: ttl);
            if (Client.Fairly) Channel.BasicQos(0, 1, false);
        }

        public IEnumerator&lt;IMessage&gt; GetEnumerator() =&gt; _enumerator ?? (_enumerator = new MessageEnumerator(Channel, Queue));

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        public void Dispose()
        {
            Channel?.Dispose();
            Connection?.Dispose();
        }

        public class MessageEnumerator : IEnumerator&lt;IMessage&gt;
        {
            public IModel Channel { get; }
            public string Queue { get; }
            public int Index { get; private set; }
            public BasicGetResult CurrentResult { get; private set; }
            public List&lt;IMessage&gt; Messages { get; }
            public IMessage Current =&gt; Messages[Index];
            object IEnumerator.Current =&gt; Current;

            public MessageEnumerator(IModel channel, string queue)
            {
                Channel = channel;
                Queue = queue;
                Index = -1;
                CurrentResult = null;
                Messages = new List&lt;IMessage&gt;();
            }

            public bool MoveNext()
            {
                int nextIndex = Index + 1;
                if (nextIndex &gt; Messages.Count - 1)
                {
                    if (CurrentResult != null)
                    {
                        Channel.BasicAck(CurrentResult.DeliveryTag, false);
                    }
                    CurrentResult = Channel.BasicGet(Queue, false);
                    if (CurrentResult != null)
                    {
                        IMessage message = GetMessage(CurrentResult);
                        Trace.TraceInformation($"Get message[{message.Content}]");
                        Messages.Add(message);
                    }
                }
                if (nextIndex &lt; Messages.Count)
                {
                    Index = nextIndex;
                    return true;
                }
                return false;
            }

            protected virtual IMessage GetMessage(BasicGetResult result)
            {
                return new Message(result);
            }

            public void Reset()
            {
                Index = -1;
            }

            public void Dispose()
            {
                Reset();
            }
        }
    }
}</value>
    <comment>${SLN}$\${NR}$.Framework\RabbitMQ.Client\MessageQueue.cs</comment>
  </data>
  <data name="Framework_RabbitMQ_Client_MessageQueue_1_cs" xml:space="preserve">
    <value>using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace RabbitMQ.Client
{
    public class MessageQueue&lt;T&gt; : MessageQueue, IMessageQueue&lt;T&gt;
    {
        private MessageEnumerator _enumerator;

        public MessageQueue(IMqClient client, string queue, string queueType = null, uint ttl = 0)
            : base(client, queue, queueType, ttl)
        {
        }

        IEnumerator&lt;IMessage&lt;T&gt;&gt; IEnumerable&lt;IMessage&lt;T&gt;&gt;.GetEnumerator() =&gt; _enumerator ?? (_enumerator = new MessageEnumerator(Channel, Queue));

        public new class MessageEnumerator : MessageQueue.MessageEnumerator, IEnumerator&lt;IMessage&lt;T&gt;&gt;
        {
            public MessageEnumerator(IModel channel, string queue)
                : base(channel, queue)
            {
            }

            IMessage&lt;T&gt; IEnumerator&lt;IMessage&lt;T&gt;&gt;.Current =&gt; (IMessage&lt;T&gt;)Current;

            protected override IMessage GetMessage(BasicGetResult result)
            {
                return new Message&lt;T&gt;(result);
            }
        }
    }
}</value>
    <comment>${SLN}$\${NR}$.Framework\RabbitMQ.Client\MessageQueue`1.cs</comment>
  </data>
  <data name="Framework_RabbitMQ_Client_MqClient_cs" xml:space="preserve">
    <value>using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Configuration;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace RabbitMQ.Client
{
    public class MqClient : IMqClient
    {
        public const string DEFAULTUSERNAME = "timetrackpro";
        public const string DEFAULTPASSWORD = "tp2000";

        public static IMqClient FromConfig(string jsonFileName)
        {
            string jsonFile = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, jsonFileName);
            string json = File.ReadAllText(jsonFile);
            return JsonConvert.DeserializeObject&lt;MqClient&gt;(json);
        }

        private string _exchange;
        private string _exchangeRetry;
        private string _exchangeFailed;
        private IConnectionFactory _factory;

        public MqClient()
        {
            ExchangeType = ExchangeTypes.Direct;
            Durable = true;
            Fairly = true;
        }

        public MqClient(string userName, string password, params string[] hostNames) : this()
        {
            UserName = userName;
            Password = password;
            HostNames = hostNames;
        }

        public string UserName { get; set; }
        public string Password { get; set; }
        public IList&lt;string&gt; HostNames { get; set; }
        public bool Durable { get; set; }
        public bool Fairly { get; set; }
        public string ExchangeType { get; set; }

        public string Exchange =&gt; _exchange ?? (_exchange = $"x.{ExchangeType}");
        public string ExchangeRetry =&gt; _exchangeRetry ?? (_exchangeRetry = $"x.{ExchangeType}.retry");
        public string ExchangeFailed =&gt; _exchangeFailed ?? (_exchangeFailed = $"x.{ExchangeType}.failed");
        public IConnectionFactory Factory
        {
            get
            {
                if (_factory == null)
                {
                    _factory = new ConnectionFactory();
                    {
                        _factory.UserName = UserName.Equals(nameof(DEFAULTUSERNAME), StringComparison.OrdinalIgnoreCase) ? DEFAULTUSERNAME : UserName;
                        _factory.Password = Password.Equals(nameof(DEFAULTPASSWORD), StringComparison.OrdinalIgnoreCase) ? DEFAULTPASSWORD : Password;
                        _factory.ClientProperties.Add("connection_name", "RabbitMQ.Client"); // 为兼容3.5.7显示客户端名称问题
                        _factory.ClientProperties.Add("tag", "RabbitMQ.Client");             // 为解决5.2.0版本不显示客户端名称问题
                    }
                }
                return _factory;
            }
        }

        public IConnection CreateConnection()
        {
            IConnection connection = Factory.CreateConnection(HostNames);
            return connection;
        }

        public IMessageProducer CreateProducer(string routingKey, ExchangeModes exchangeMode = ExchangeModes.Normal, string queueType = null, uint ttl = 0)
        {
            return new MessageProducer(this, routingKey, exchangeMode, queueType, ttl);
        }

        public IMessageProducer&lt;T&gt; CreateProducer&lt;T&gt;(string routingKey, ExchangeModes exchangeMode = ExchangeModes.Normal, string queueType = null, uint ttl = 0)
        {
            return new MessageProducer&lt;T&gt;(this, routingKey, exchangeMode, queueType, ttl);
        }

        public IMessageConsumer CreateConsumer(string routingKey, ExchangeModes exchangeMode = ExchangeModes.Normal, string queueType = null, uint ttl = 0)
        {
            return new MessageConsumer(this, routingKey, exchangeMode, queueType, ttl);
        }

        public IMessageConsumer&lt;T&gt; CreateConsumer&lt;T&gt;(string routingKey, ExchangeModes exchangeMode = ExchangeModes.Normal, string queueType = null, uint ttl = 0)
        {
            return new MessageConsumer&lt;T&gt;(this, routingKey, exchangeMode, queueType, ttl);
        }

        public IRemoteProcedure CreateRemoteProcedure(string routingKey, ExchangeModes exchangeMode = ExchangeModes.Normal, string queueType = null, uint ttl = 0)
        {
            return new RemoteProcedure(this, routingKey, exchangeMode, queueType, ttl);
        }

        public IRemoteProcedure&lt;TSource, TResult&gt; CreateRemoteProcedure&lt;TSource, TResult&gt;(string routingKey, ExchangeModes exchangeMode = ExchangeModes.Normal, string queueType = null, uint ttl = 0)
        {
            return new RemoteProcedure&lt;TSource, TResult&gt;(this, routingKey, exchangeMode, queueType, ttl);
        }

        public IMessageQueue GetMessageQueue(string queue, string queueType = null, uint ttl = 0)
        {
            return new MessageQueue(this, queue, queueType, ttl);
        }

        public IMessageQueue&lt;T&gt; GetMessageQueue&lt;T&gt;(string queue, string queueType = null, uint ttl = 0)
        {
            return new MessageQueue&lt;T&gt;(this, queue, queueType, ttl);
        }

        public void SetRoute(IModel channel, string routingKey, ExchangeModes exchangeMode = ExchangeModes.Normal, string queueType = null, uint ttl = 0)
        {
            string queue = $"{routingKey}";

            IDictionary&lt;string, object&gt; args = new Dictionary&lt;string, object&gt;();
            {
                if (!string.IsNullOrWhiteSpace(queueType))
                    args.Add(ArgumentKeys.QueueType, queueType);
                if (ttl &gt; 0)
                    args.Add(ArgumentKeys.TimeToLive, ttl);
            }

            channel.ExchangeDeclare(Exchange, ExchangeType, Durable, false, null);
            channel.QueueDeclare(queue, Durable, false, false, args);
            channel.QueueBind(queue, Exchange, routingKey);

            if (exchangeMode == ExchangeModes.DLX)
            {
                string queueRetry = $"{routingKey}.retry";
                string queueFailed = $"{routingKey}.failed";

                args[ArgumentKeys.DeadLetterExchange] = ExchangeFailed;         // 指定死信交换机，用于将 Noraml 队列中失败的消息投递给 Failed 交换机

                IDictionary&lt;string, object&gt; retryArgs = new Dictionary&lt;string, object&gt;();
                {
                    if (!string.IsNullOrWhiteSpace(queueType))
                        retryArgs[ArgumentKeys.QueueType] = queueType;
                    retryArgs[ArgumentKeys.DeadLetterExchange] = Exchange;              // 指定死信交换机，用于将 Retry 队列中超时的消息投递给 Noraml 交换机
                    retryArgs[ArgumentKeys.TimeToLive] = ttl &gt; 0 ? ttl : (6 * 1000);    // 定义 queueRetry 的消息最大停留时间 (原理是：等消息超时后由 broker 自动投递给当前绑定的死信交换机)
                                                                                        // 定义最大停留时间为防止一些 待重新投递 的消息、没有定义重试时间而导致内存溢出
                }

                IDictionary&lt;string, object&gt; failedArgs = new Dictionary&lt;string, object&gt;();
                {
                    if (!string.IsNullOrWhiteSpace(queueType))
                        failedArgs[ArgumentKeys.QueueType] = queueType;
                }

                channel.ExchangeDeclare(ExchangeRetry, ExchangeType, Durable, false, null);
                channel.QueueDeclare(queueRetry, Durable, false, false, retryArgs);
                channel.QueueBind(queueRetry, ExchangeRetry, routingKey);

                channel.ExchangeDeclare(ExchangeFailed, ExchangeType, Durable, false, null);
                channel.QueueDeclare(queueFailed, Durable, false, false, failedArgs);
                channel.QueueBind(queueFailed, ExchangeFailed, routingKey);
            }
        }
    }
}</value>
    <comment>${SLN}$\${NR}$.Framework\RabbitMQ.Client\MqClient.cs</comment>
  </data>
  <data name="Framework_RabbitMQ_Client_RemoteProcedure_cs" xml:space="preserve">
    <value>using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace RabbitMQ.Client
{
    public class RemoteProcedure : IRemoteProcedure
    {
        protected readonly List&lt;IMessage&gt; _resultList;
        protected readonly Dictionary&lt;string, AutoResetEvent&gt; _waitMap;

        public event EventHandler Disposed;

        public IMqClient Client { get; }

        public string RoutingKey { get; }
        public ExchangeModes ExchangeMode { get; }
        public string QueueType { get; }
        public uint Ttl { get; }
        private IMessageProducer Producer { get; set; }
        private IMessageConsumer Consumer { get; set; }

        public RemoteProcedure(IMqClient client, string routingKey, ExchangeModes exchangeMode = ExchangeModes.Normal, string queueType = null, uint ttl = 0)
        {
            _resultList = new List&lt;IMessage&gt;();
            _waitMap = new Dictionary&lt;string, AutoResetEvent&gt;();

            Client = client;
            RoutingKey = routingKey;
            ExchangeMode = exchangeMode;
            QueueType = queueType;
            Ttl = ttl;
        }

        protected virtual bool Reply(IMessage result)
        {
            if (_waitMap.ContainsKey(result.CorrelationId))
            {
                lock (_resultList)
                {
                    _resultList.Add(result);
                }
                _waitMap[result.CorrelationId].Set();
                return true;
            }
            return false;
        }

        public virtual string Call(string content, int timeout = 30 * 1000)
        {
            if (Producer == null)
            {
                Producer = new MessageProducer(Client, RoutingKey, ExchangeMode, QueueType, Ttl);
                Disposed += delegate { Producer?.Dispose(); };
                Producer.ReplyTo(x =&gt; Reply(x));
            }
            IMessage message = Producer.Publish(content);
            lock (_waitMap)
            {
                _waitMap[message.CorrelationId] = new AutoResetEvent(false);
            }
            if (_waitMap[message.CorrelationId].WaitOne(timeout))
            {
                _waitMap[message.CorrelationId].Dispose();
                lock (_waitMap)
                {
                    _waitMap.Remove(message.CorrelationId);
                }
                IMessage result = _resultList.FirstOrDefault(x =&gt; x.CorrelationId == message.CorrelationId);
                if (result != null)
                {
                    lock (_resultList)
                    {
                        _resultList.Remove(result);
                    }
                    return result.Content;
                }
                Trace.TraceError($"Missing message[CorrelationId:{message.CorrelationId}]");
            }
            else
            {
                Trace.TraceError($"RemoteProcedure[{RoutingKey}] answer timeout.");
            }
            return null;
        }

        public async Task&lt;string&gt; CallAsync(string content, int timeout = 30 * 1000)
        {
            return await Task.Run(() =&gt; Call(content, timeout));
        }

        public void Answer(Func&lt;IMessage, string&gt; handler)
        {
            if (Consumer == null)
            {
                Consumer = new MessageConsumer(Client, RoutingKey, ExchangeMode, QueueType, Ttl);
                Disposed += delegate { Consumer?.Dispose(); };
            }
            Consumer.Subscribe(handler);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (disposing)
            {
                Disposed?.Invoke(this, EventArgs.Empty);
            }
        }

        public void Dispose()
        {
            Dispose(true);
        }

        ~RemoteProcedure()
        {
            Dispose(false);
            GC.SuppressFinalize(this);
        }
    }
}</value>
    <comment>${SLN}$\${NR}$.Framework\RabbitMQ.Client\RemoteProcedure.cs</comment>
  </data>
  <data name="Framework_RabbitMQ_Client_RemoteProcedure_1_cs" xml:space="preserve">
    <value>using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace RabbitMQ.Client
{
    public class RemoteProcedure&lt;TSource, TResult&gt; : RemoteProcedure, IRemoteProcedure&lt;TSource, TResult&gt;
    {
        private IMessageProducer&lt;TSource&gt; Producer { get; set; }
        private IMessageConsumer&lt;TSource&gt; Consumer { get; set; }

        public RemoteProcedure(IMqClient client, string routingKey, ExchangeModes exchangeMode = ExchangeModes.Normal, string queueType = null, uint ttl = 0)
            : base(client, routingKey, exchangeMode, queueType, ttl)
        {
        }

        public TResult Call(TSource source, int timeout = 30 * 1000)
        {
            if (Producer == null)
            {
                Producer = new MessageProducer&lt;TSource&gt;(Client, RoutingKey, ExchangeMode, QueueType, Ttl);
                Disposed += delegate { Producer?.Dispose(); };
                Producer.ReplyTo&lt;TResult&gt;(Reply);
            }
            IMessage message = Producer.Publish(source);
            lock (_waitMap)
            {
                _waitMap[message.CorrelationId] = new AutoResetEvent(false);
            }
            if (_waitMap[message.CorrelationId].WaitOne(timeout))
            {
                _waitMap[message.CorrelationId].Dispose();
                lock (_waitMap)
                {
                    _waitMap.Remove(message.CorrelationId);
                }
                IMessage result = _resultList.FirstOrDefault(x =&gt; x.CorrelationId == message.CorrelationId);
                if (result != null)
                {
                    lock (_resultList)
                    {
                        _resultList.Remove(result);
                    }
                    return ((IMessage&lt;TResult&gt;)result).Value;
                }
                Trace.TraceError($"Missing message[CorrelationId:{message.CorrelationId}]");
            }
            else
            {
                Trace.TraceError($"RemoteProcedure[{RoutingKey}] answer timeout.");
            }
            return default(TResult);
        }

        public async Task&lt;TResult&gt; CallAsync(TSource source, int timeout = 30 * 1000)
        {
            return await Task.Run(() =&gt; Call(source, timeout));
        }

        public void Answer(Func&lt;IMessage&lt;TSource&gt;, TResult&gt; handler)
        {
            if (Consumer == null)
            {
                Consumer = new MessageConsumer&lt;TSource&gt;(Client, RoutingKey, ExchangeMode, QueueType, Ttl);
                Disposed += delegate { Consumer?.Dispose(); };
            }
            Consumer.Subscribe(handler);
        }
    }
}</value>
    <comment>${SLN}$\${NR}$.Framework\RabbitMQ.Client\RemoteProcedure`2.cs</comment>
  </data>
  <data name="Framework_RabbitMQ_Client_Roles_IMessage_cs" xml:space="preserve">
    <value>using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace RabbitMQ.Client
{
    public interface IMessage
    {
        string CorrelationId { get; set; }
        ulong DeliveryTag { get; set; }
        string ReplyTo { get; set; }
        string Content { get; }
        [JsonIgnore]
        byte[] Body { get; }
        void Backup(string path);
        IMessage&lt;T&gt; Cast&lt;T&gt;();
    }
}</value>
    <comment>${SLN}$\${NR}$.Framework\RabbitMQ.Client\Roles\IMessage.cs</comment>
  </data>
  <data name="Framework_RabbitMQ_Client_Roles_IMessage_1_cs" xml:space="preserve">
    <value>using Newtonsoft.Json;

namespace RabbitMQ.Client
{
    public interface IMessage&lt;out T&gt;: IMessage
    {
        T Value { get; }
    }
}</value>
    <comment>${SLN}$\${NR}$.Framework\RabbitMQ.Client\Roles\IMessage`1.cs</comment>
  </data>
  <data name="Models_csproj" xml:space="preserve">
    <value>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003"&gt;
  &lt;Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" /&gt;
  &lt;PropertyGroup&gt;
    &lt;Configuration Condition=" '$(Configuration)' == '' "&gt;Debug&lt;/Configuration&gt;
    &lt;Platform Condition=" '$(Platform)' == '' "&gt;AnyCPU&lt;/Platform&gt;
    &lt;ProjectGuid&gt;{${ModelsProjectGuid}$}&lt;/ProjectGuid&gt;
    &lt;OutputType&gt;Library&lt;/OutputType&gt;
    &lt;AppDesignerFolder&gt;Properties&lt;/AppDesignerFolder&gt;
    &lt;RootNamespace&gt;${NR}$.Models&lt;/RootNamespace&gt;
    &lt;AssemblyName&gt;${NR}$.Models&lt;/AssemblyName&gt;
    &lt;TargetFrameworkVersion&gt;v4.6.1&lt;/TargetFrameworkVersion&gt;
    &lt;FileAlignment&gt;512&lt;/FileAlignment&gt;
    &lt;Deterministic&gt;true&lt;/Deterministic&gt;
    &lt;SccProjectName&gt;
    &lt;/SccProjectName&gt;
    &lt;SccLocalPath&gt;
    &lt;/SccLocalPath&gt;
    &lt;SccAuxPath&gt;
    &lt;/SccAuxPath&gt;
    &lt;SccProvider&gt;
    &lt;/SccProvider&gt;
  &lt;/PropertyGroup&gt;
  &lt;PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' "&gt;
    &lt;DebugSymbols&gt;true&lt;/DebugSymbols&gt;
    &lt;DebugType&gt;full&lt;/DebugType&gt;
    &lt;Optimize&gt;false&lt;/Optimize&gt;
    &lt;OutputPath&gt;bin\Debug\&lt;/OutputPath&gt;
    &lt;DefineConstants&gt;DEBUG;TRACE&lt;/DefineConstants&gt;
    &lt;ErrorReport&gt;prompt&lt;/ErrorReport&gt;
    &lt;WarningLevel&gt;4&lt;/WarningLevel&gt;
  &lt;/PropertyGroup&gt;
  &lt;PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' "&gt;
    &lt;DebugType&gt;pdbonly&lt;/DebugType&gt;
    &lt;Optimize&gt;true&lt;/Optimize&gt;
    &lt;OutputPath&gt;bin\Release\&lt;/OutputPath&gt;
    &lt;DefineConstants&gt;TRACE&lt;/DefineConstants&gt;
    &lt;ErrorReport&gt;prompt&lt;/ErrorReport&gt;
    &lt;WarningLevel&gt;4&lt;/WarningLevel&gt;
  &lt;/PropertyGroup&gt;
  &lt;ItemGroup&gt;
    &lt;Reference Include="AutoMapper, Version=5.0.2.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005, processorArchitecture=MSIL"&gt;
      &lt;HintPath&gt;..\packages\AutoMapper.5.0.2\lib\net45\AutoMapper.dll&lt;/HintPath&gt;
    &lt;/Reference&gt;
    &lt;Reference Include="AutoMapper.Attributes, Version=6.0.1.0, Culture=neutral, processorArchitecture=MSIL"&gt;
      &lt;HintPath&gt;..\packages\AutoMapper.Attributes.6.0.1\lib\net45\AutoMapper.Attributes.dll&lt;/HintPath&gt;
    &lt;/Reference&gt;
    &lt;Reference Include="Dapper, Version=2.0.0.0, Culture=neutral, processorArchitecture=MSIL"&gt;
      &lt;HintPath&gt;..\packages\Dapper.2.0.123\lib\net461\Dapper.dll&lt;/HintPath&gt;
    &lt;/Reference&gt;
    &lt;Reference Include="Dapper.Contrib, Version=2.0.0.0, Culture=neutral, processorArchitecture=MSIL"&gt;
      &lt;HintPath&gt;..\packages\Dapper.Contrib.2.0.78\lib\net461\Dapper.Contrib.dll&lt;/HintPath&gt;
    &lt;/Reference&gt;
    &lt;Reference Include="Newtonsoft.Json, Version=13.0.0.0, Culture=neutral, PublicKeyToken=30ad4fe6b2a6aeed, processorArchitecture=MSIL"&gt;
      &lt;HintPath&gt;..\packages\Newtonsoft.Json.13.0.1\lib\net45\Newtonsoft.Json.dll&lt;/HintPath&gt;
    &lt;/Reference&gt;
    &lt;Reference Include="System" /&gt;
    &lt;Reference Include="System.Core" /&gt;
    &lt;Reference Include="System.Web" /&gt;
    &lt;Reference Include="System.Xml.Linq" /&gt;
    &lt;Reference Include="System.Data.DataSetExtensions" /&gt;
    &lt;Reference Include="Microsoft.CSharp" /&gt;
    &lt;Reference Include="System.Data" /&gt;
    &lt;Reference Include="System.Net.Http" /&gt;
    &lt;Reference Include="System.Xml" /&gt;
  &lt;/ItemGroup&gt;
  &lt;ItemGroup&gt;
    &lt;Compile Include="AutoMapper\MapperConfig.cs" /&gt;
    &lt;Compile Include="Base\BaseModel.cs" /&gt;
    &lt;Compile Include="Base\IAuditModel.cs" /&gt;
    &lt;Compile Include="Base\IIdentityModel.cs" /&gt;
    &lt;Compile Include="Base\IIdentityModel`1.cs" /&gt;
    &lt;Compile Include="Base\IModel.cs" /&gt;
    &lt;Compile Include="Base\PaggedOutput.cs" /&gt;
    &lt;Compile Include="Properties\AssemblyInfo.cs" /&gt;
  &lt;/ItemGroup&gt;
  &lt;ItemGroup&gt;
    &lt;None Include="app.config" /&gt;
    &lt;None Include="Manager.ttinclude" /&gt;
    &lt;None Include="packages.config" /&gt;
  &lt;/ItemGroup&gt;
  &lt;ItemGroup&gt;
    &lt;ProjectReference Include="..\${NR}$.Framework\${NR}$.Framework.csproj"&gt;
      &lt;Project&gt;{${FrameworkProjectGuid}$}&lt;/Project&gt;
      &lt;Name&gt;${NR}$.Framework&lt;/Name&gt;
    &lt;/ProjectReference&gt;
  &lt;/ItemGroup&gt;
  &lt;ItemGroup&gt;
    &lt;Service Include="{508349B6-6B84-4DF5-91F0-309BEEBAD82D}" /&gt;
  &lt;/ItemGroup&gt;
  &lt;ItemGroup&gt;
    &lt;Content Include="Models.tt"&gt;
      &lt;Generator&gt;TextTemplatingFileGenerator&lt;/Generator&gt;
    &lt;/Content&gt;
  &lt;/ItemGroup&gt;
  &lt;Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" /&gt;
&lt;/Project&gt;</value>
    <comment>${SLN}$\${NR}$.Models\${NR}$.Models.csproj</comment>
  </data>
  <data name="Framework_RabbitMQ_Client_Roles_IMessageConsumer_cs" xml:space="preserve">
    <value>using RabbitMQ.Client.Events;
using System;
using System.ComponentModel;

namespace RabbitMQ.Client
{
    /// &lt;summary&gt;
    /// 消息消费者
    /// &lt;/summary&gt;
    public interface IMessageConsumer : IDisposable
    {
        event EventHandler Disposed;

        /// &lt;summary&gt;
        /// 客户端
        /// &lt;/summary&gt;
        IMqClient Client { get; }

        /// &lt;summary&gt;
        /// 连接
        /// &lt;/summary&gt;
        IConnection Connection { get; }

        /// &lt;summary&gt;
        /// 通道
        /// &lt;/summary&gt;
        IModel Channel { get; }

        /// &lt;summary&gt;
        /// 路由键
        /// &lt;/summary&gt;
        string RoutingKey { get; }

        /// &lt;summary&gt;
        /// 交换模式
        /// &lt;/summary&gt;
        ExchangeModes ExchangeMode { get; }

        /// &lt;summary&gt;
        /// 队列类型
        /// &lt;/summary&gt;
        string QueueType { get; }

        /// &lt;summary&gt;
        /// 消息存活时间
        /// &lt;/summary&gt;
        uint Ttl { get; }

        /// &lt;summary&gt;
        /// 订阅
        /// &lt;/summary&gt;
        /// &lt;param name="handler"&gt;消息处理方法&lt;/param&gt;
        void Subscribe(Func&lt;IMessage, object&gt; handler);

        /// &lt;summary&gt;
        /// 订阅
        /// &lt;/summary&gt;
        /// &lt;param name="handler"&gt;消息处理方法&lt;/param&gt;
        void Subscribe(Action&lt;IMessage&gt; handler);
    }
}</value>
    <comment>${SLN}$\${NR}$.Framework\RabbitMQ.Client\Roles\IMessageConsumer.cs</comment>
  </data>
  <data name="Framework_RabbitMQ_Client_Roles_IMessageConsumer_1_cs" xml:space="preserve">
    <value>using System;
using System.ComponentModel;

namespace RabbitMQ.Client
{
    /// &lt;summary&gt;
    /// 消息消费者
    /// &lt;/summary&gt;
    public interface IMessageConsumer&lt;T&gt; : IMessageConsumer
    {
        /// &lt;summary&gt;
        /// 订阅
        /// &lt;/summary&gt;
        /// &lt;param name="handler"&gt;消息处理方法&lt;/param&gt;
        void Subscribe(Action&lt;IMessage&lt;T&gt;&gt; handler);

        /// &lt;summary&gt;
        /// 订阅
        /// &lt;/summary&gt;
        /// &lt;param name="handler"&gt;消息处理方法&lt;/param&gt;
        void Subscribe&lt;TReply&gt;(Func&lt;IMessage&lt;T&gt;, TReply&gt; handler);
    }
}</value>
    <comment>${SLN}$\${NR}$.Framework\RabbitMQ.Client\Roles\IMessageConsumer`1.cs</comment>
  </data>
  <data name="Framework_RabbitMQ_Client_Roles_IMessageProducer_cs" xml:space="preserve">
    <value>using System;
using System.ComponentModel;

namespace RabbitMQ.Client
{
    /// &lt;summary&gt;
    /// 消息生产者
    /// &lt;/summary&gt;
    public interface IMessageProducer : IDisposable
    {
        event EventHandler Disposed;
        event Action&lt;string&gt; PublishSuccess;
        event Action&lt;string&gt; PublishFailed;

        /// &lt;summary&gt;
        /// 客户端
        /// &lt;/summary&gt;
        IMqClient Client { get; }

        /// &lt;summary&gt;
        /// 连接
        /// &lt;/summary&gt;
        IConnection Connection { get; }

        /// &lt;summary&gt;
        /// 通道
        /// &lt;/summary&gt;
        IModel Channel { get; }

        /// &lt;summary&gt;
        /// 路由键
        /// &lt;/summary&gt;
        string RoutingKey { get; }

        /// &lt;summary&gt;
        /// 交换模式
        /// &lt;/summary&gt;
        ExchangeModes ExchangeMode { get; }

        /// &lt;summary&gt;
        /// 队列类型
        /// &lt;/summary&gt;
        string QueueType { get; }

        /// &lt;summary&gt;
        /// 消息存活时间
        /// &lt;/summary&gt;
        uint Ttl { get; }

        /// &lt;summary&gt;
        /// 发布
        /// &lt;/summary&gt;
        /// &lt;param name="content"&gt;消息内容&lt;/param&gt;
        /// &lt;param name="correlationId"&gt;相关ID&lt;/param&gt;
        /// &lt;returns&gt;消息实体&lt;/returns&gt;
        IMessage Publish(string content, string correlationId = null);

        /// &lt;summary&gt;
        /// 回发
        /// &lt;/summary&gt;
        /// &lt;typeparam name="TReply"&gt;回发消息类型&lt;/typeparam&gt;
        /// &lt;param name="callback"&gt;回调函数&lt;/param&gt;
        /// &lt;param name="replyRoutingKey"&gt;回发路由键 (默认: r.routingKey)&lt;/param&gt;
        IMessageProducer ReplyTo(Func&lt;IMessage, object&gt; callback, string replyRoutingKey = null);

        /// &lt;summary&gt;
        /// 等待确认
        /// &lt;/summary&gt;
        /// &lt;param name="timeout"&gt;最大等待时长&lt;/param&gt;
        void WaitForConfirmsOrDie(TimeSpan timeout);
    }
}</value>
    <comment>${SLN}$\${NR}$.Framework\RabbitMQ.Client\Roles\IMessageProducer.cs</comment>
  </data>
  <data name="Framework_RabbitMQ_Client_Roles_IMessageProducer_1_cs" xml:space="preserve">
    <value>using System;
using System.ComponentModel;

namespace RabbitMQ.Client
{
    /// &lt;summary&gt;
    /// 消息生产者
    /// &lt;/summary&gt;
    public interface IMessageProducer&lt;T&gt; : IMessageProducer
    {
        /// &lt;summary&gt;
        /// 发布
        /// &lt;/summary&gt;
        /// &lt;param name="message"&gt;消息&lt;/param&gt;
        /// &lt;param name="correlationId"&gt;相关ID&lt;/param&gt;
        /// &lt;returns&gt;消息实体&lt;/returns&gt;
        IMessage&lt;T&gt; Publish(T message, string correlationId = null);

        /// &lt;summary&gt;
        /// 回发
        /// &lt;/summary&gt;
        /// &lt;typeparam name="TReply"&gt;回发消息类型&lt;/typeparam&gt;
        /// &lt;param name="callback"&gt;回调函数&lt;/param&gt;
        /// &lt;param name="replyRoutingKey"&gt;回发路由键 (默认: r.routingKey)&lt;/param&gt;
        IMessageProducer&lt;T&gt; ReplyTo&lt;TReply&gt;(Func&lt;IMessage&lt;TReply&gt;, bool&gt; callback, string replyRoutingKey = null);
    }
}</value>
    <comment>${SLN}$\${NR}$.Framework\RabbitMQ.Client\Roles\IMessageProducer`1.cs</comment>
  </data>
  <data name="Framework_RabbitMQ_Client_Roles_IMessageQueue_cs" xml:space="preserve">
    <value>using System;
using System.Collections.Generic;

namespace RabbitMQ.Client
{
    /// &lt;summary&gt;
    /// 消息队列
    /// &lt;/summary&gt;
    /// &lt;typeparam name="T"&gt;&lt;/typeparam&gt;
    public interface IMessageQueue : IEnumerable&lt;IMessage&gt;, IDisposable
    {
        /// &lt;summary&gt;
        /// 客户端
        /// &lt;/summary&gt;
        IMqClient Client { get; }

        /// &lt;summary&gt;
        /// 连接
        /// &lt;/summary&gt;
        IConnection Connection { get; }

        /// &lt;summary&gt;
        /// 通道
        /// &lt;/summary&gt;
        IModel Channel { get; }

        /// &lt;summary&gt;
        /// 队列
        /// &lt;/summary&gt;
        string Queue { get; }
    }
}</value>
    <comment>${SLN}$\${NR}$.Framework\RabbitMQ.Client\Roles\IMessageQueue.cs</comment>
  </data>
  <data name="Framework_RabbitMQ_Client_Roles_IMessageQueue_1_cs" xml:space="preserve">
    <value>using System;
using System.Collections.Generic;

namespace RabbitMQ.Client
{
    /// &lt;summary&gt;
    /// 消息队列
    /// &lt;/summary&gt;
    /// &lt;typeparam name="T"&gt;&lt;/typeparam&gt;
    public interface IMessageQueue&lt;T&gt; : IEnumerable&lt;IMessage&lt;T&gt;&gt;, IDisposable
    {
        /// &lt;summary&gt;
        /// 客户端
        /// &lt;/summary&gt;
        IMqClient Client { get; }

        /// &lt;summary&gt;
        /// 连接
        /// &lt;/summary&gt;
        IConnection Connection { get; }

        /// &lt;summary&gt;
        /// 通道
        /// &lt;/summary&gt;
        IModel Channel { get; }

        /// &lt;summary&gt;
        /// 队列
        /// &lt;/summary&gt;
        string Queue { get; }
    }
}</value>
    <comment>${SLN}$\${NR}$.Framework\RabbitMQ.Client\Roles\IMessageQueue`1.cs</comment>
  </data>
  <data name="Framework_RabbitMQ_Client_Roles_IMqClient_cs" xml:space="preserve">
    <value>using System.Collections.Generic;

namespace RabbitMQ.Client
{
    /// &lt;summary&gt;
    /// 消息队列客户端
    /// &lt;/summary&gt;
    public interface IMqClient
    {
        /// &lt;summary&gt;
        /// 用户名
        /// &lt;/summary&gt;
        string UserName { get; set; }

        /// &lt;summary&gt;
        /// 密码
        /// &lt;/summary&gt;
        string Password { get; set; }

        /// &lt;summary&gt;
        /// 服务主机（集群则多个）
        /// &lt;/summary&gt;
        IList&lt;string&gt; HostNames { get; set; }

        /// &lt;summary&gt;
        /// 持久化
        /// &lt;/summary&gt;
        bool Durable { get; set; }

        /// &lt;summary&gt;
        /// 公平分发
        /// &lt;/summary&gt;
        bool Fairly { get; set; }

        /// &lt;summary&gt;
        /// 交换类型
        /// &lt;/summary&gt;
        string ExchangeType { get; set; }

        /// &lt;summary&gt;
        /// 接收正常消息的交换机
        /// &lt;/summary&gt;
        string Exchange { get; }

        /// &lt;summary&gt;
        /// 接收重试消息的交换机
        /// &lt;/summary&gt;
        string ExchangeRetry { get; }

        /// &lt;summary&gt;
        /// 接收失败消息的交换机
        /// &lt;/summary&gt;
        string ExchangeFailed { get; }

        /// &lt;summary&gt;
        /// 连接工厂
        /// &lt;/summary&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        IConnectionFactory Factory { get; }

        /// &lt;summary&gt;
        /// 创建连接
        /// &lt;/summary&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        IConnection CreateConnection();

        /// &lt;summary&gt;
        /// 创建生产者
        /// &lt;/summary&gt;
        /// &lt;param name="routingKey"&gt;路由键&lt;/param&gt;
        /// &lt;param name="exchangeMode"&gt;交换模式&lt;/param&gt;
        /// &lt;param name="queueType"&gt;队列类型&lt;/param&gt;
        /// &lt;param name="ttl"&gt;消息存活时长&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        IMessageProducer CreateProducer(string routingKey, ExchangeModes exchangeMode = ExchangeModes.Normal, string queueType = null, uint ttl = 0);

        /// &lt;summary&gt;
        /// 创建生产者
        /// &lt;/summary&gt;
        /// &lt;typeparam name="T"&gt;消息类型&lt;/typeparam&gt;
        /// &lt;param name="routingKey"&gt;路由键&lt;/param&gt;
        /// &lt;param name="exchangeMode"&gt;交换模式&lt;/param&gt;
        /// &lt;param name="queueType"&gt;队列类型&lt;/param&gt;
        /// &lt;param name="ttl"&gt;消息存活时长&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        IMessageProducer&lt;T&gt; CreateProducer&lt;T&gt;(string routingKey, ExchangeModes exchangeMode = ExchangeModes.Normal, string queueType = null, uint ttl = 0);

        /// &lt;summary&gt;
        /// 创建消费者
        /// &lt;/summary&gt;
        /// &lt;param name="routingKey"&gt;路由键&lt;/param&gt;
        /// &lt;param name="exchangeMode"&gt;交换模式&lt;/param&gt;
        /// &lt;param name="queueType"&gt;队列类型&lt;/param&gt;
        /// &lt;param name="ttl"&gt;消息存活时长&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        IMessageConsumer CreateConsumer(string routingKey, ExchangeModes exchangeMode = ExchangeModes.Normal, string queueType = null, uint ttl = 0);

        /// &lt;summary&gt;
        /// 创建消费者
        /// &lt;/summary&gt;
        /// &lt;typeparam name="T"&gt;消息类型&lt;/typeparam&gt;
        /// &lt;param name="routingKey"&gt;路由键&lt;/param&gt;
        /// &lt;param name="exchangeMode"&gt;交换模式&lt;/param&gt;
        /// &lt;param name="queueType"&gt;队列类型&lt;/param&gt;
        /// &lt;param name="ttl"&gt;消息存活时长&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        IMessageConsumer&lt;T&gt; CreateConsumer&lt;T&gt;(string routingKey, ExchangeModes exchangeMode = ExchangeModes.Normal, string queueType = null, uint ttl = 0);

        /// &lt;summary&gt;
        /// 创建远程过程
        /// &lt;/summary&gt;
        /// &lt;param name="routingKey"&gt;路由键&lt;/param&gt;
        /// &lt;param name="exchangeMode"&gt;交换模式&lt;/param&gt;
        /// &lt;param name="queueType"&gt;队列类型&lt;/param&gt;
        /// &lt;param name="ttl"&gt;消息存活时长&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        IRemoteProcedure CreateRemoteProcedure(string routingKey, ExchangeModes exchangeMode = ExchangeModes.Normal, string queueType = null, uint ttl = 0);

        /// &lt;summary&gt;
        /// 创建远程过程
        /// &lt;/summary&gt;
        /// &lt;typeparam name="TSource"&gt;传入类型&lt;/typeparam&gt;
        /// &lt;typeparam name="TResult"&gt;传出类型&lt;/typeparam&gt;
        /// &lt;param name="routingKey"&gt;路由键&lt;/param&gt;
        /// &lt;param name="exchangeMode"&gt;交换模式&lt;/param&gt;
        /// &lt;param name="queueType"&gt;队列类型&lt;/param&gt;
        /// &lt;param name="ttl"&gt;消息存活时长&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        IRemoteProcedure&lt;TSource, TResult&gt; CreateRemoteProcedure&lt;TSource, TResult&gt;(string routingKey, ExchangeModes exchangeMode = ExchangeModes.Normal, string queueType = null, uint ttl = 0);

        /// &lt;summary&gt;
        /// 获取消息队列（当前全部消息枚举列表）
        /// &lt;/summary&gt;
        /// &lt;param name="queue"&gt;队列名&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        IMessageQueue GetMessageQueue(string queue, string queueType = null, uint ttl = 0);

        /// &lt;summary&gt;
        /// 获取消息队列（当前全部消息枚举列表）
        /// &lt;/summary&gt;
        /// &lt;typeparam name="T"&gt;消息类型&lt;/typeparam&gt;
        /// &lt;param name="queue"&gt;队列名&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        IMessageQueue&lt;T&gt; GetMessageQueue&lt;T&gt;(string queue, string queueType = null, uint ttl = 0);

        /// &lt;summary&gt;
        /// 设置路由
        /// &lt;/summary&gt;
        /// &lt;param name="channel"&gt;通道&lt;/param&gt;
        /// &lt;param name="routingKey"&gt;路由键&lt;/param&gt;
        /// &lt;param name="exchangeMode"&gt;交换模式&lt;/param&gt;
        /// &lt;param name="queueType"&gt;队列类型&lt;/param&gt;
        /// &lt;param name="ttl"&gt;消息存活时长&lt;/param&gt;
        void SetRoute(IModel channel, string routingKey, ExchangeModes exchangeMode = ExchangeModes.Normal, string queueType = null, uint ttl = 0);

    }
}</value>
    <comment>${SLN}$\${NR}$.Framework\RabbitMQ.Client\Roles\IMqClient.cs</comment>
  </data>
  <data name="Framework_RabbitMQ_Client_Roles_IRemoteProcedure_cs" xml:space="preserve">
    <value>using System;
using System.ComponentModel;
using System.Threading.Tasks;

namespace RabbitMQ.Client
{
    /// &lt;summary&gt;
    /// 远程过程
    /// &lt;/summary&gt;
    public interface IRemoteProcedure : IDisposable
    {
        event EventHandler Disposed;

        /// &lt;summary&gt;
        /// 客户端
        /// &lt;/summary&gt;
        IMqClient Client { get; }

        /// &lt;summary&gt;
        /// 路由键
        /// &lt;/summary&gt;
        string RoutingKey { get; }

        /// &lt;summary&gt;
        /// 队列类型
        /// &lt;/summary&gt;
        string QueueType { get; }

        /// &lt;summary&gt;
        /// 消息存活时长
        /// &lt;/summary&gt;
        uint Ttl { get; }

        /// &lt;summary&gt;
        /// 同步调用
        /// &lt;/summary&gt;
        /// &lt;param name="content"&gt;传入消息内容&lt;/param&gt;
        /// &lt;param name="timeout"&gt;超时 ms&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        string Call(string content, int timeout = 30 * 1000);

        /// &lt;summary&gt;
        /// 异步调用
        /// &lt;/summary&gt;
        /// &lt;param name="content"&gt;传入消息内容&lt;/param&gt;
        /// &lt;param name="timeout"&gt;超时 ms&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        Task&lt;string&gt; CallAsync(string content, int timeout = 30 * 1000);

        /// &lt;summary&gt;
        /// 响应
        /// &lt;/summary&gt;
        /// &lt;param name="handler"&gt;订阅方法&lt;/param&gt;
        void Answer(Func&lt;IMessage, string&gt; handler);
    }
}</value>
    <comment>${SLN}$\${NR}$.Framework\RabbitMQ.Client\Roles\IRemoteProcedure.cs</comment>
  </data>
  <data name="Framework_RabbitMQ_Client_Roles_IRemoteProcedure_1_cs" xml:space="preserve">
    <value>using System;
using System.ComponentModel;
using System.Threading.Tasks;

namespace RabbitMQ.Client
{
    /// &lt;summary&gt;
    /// 远程过程
    /// &lt;/summary&gt;
    public interface IRemoteProcedure&lt;TSource, TResult&gt; : IDisposable
    {
        event EventHandler Disposed;

        /// &lt;summary&gt;
        /// 客户端
        /// &lt;/summary&gt;
        IMqClient Client { get; }

        /// &lt;summary&gt;
        /// 路由键
        /// &lt;/summary&gt;
        string RoutingKey { get; }

        /// &lt;summary&gt;
        /// 队列类型
        /// &lt;/summary&gt;
        string QueueType { get; }

        /// &lt;summary&gt;
        /// 消息存活时长
        /// &lt;/summary&gt;
        uint Ttl { get; }

        /// &lt;summary&gt;
        /// 同步调用
        /// &lt;/summary&gt;
        /// &lt;param name="source"&gt;传入消息内容&lt;/param&gt;
        /// &lt;param name="timeout"&gt;超时 ms&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        TResult Call(TSource source, int timeout = 30 * 1000);

        /// &lt;summary&gt;
        /// 异步调用
        /// &lt;/summary&gt;
        /// &lt;param name="source"&gt;传入消息内容&lt;/param&gt;
        /// &lt;param name="timeout"&gt;超时 ms&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        Task&lt;TResult&gt; CallAsync(TSource source, int timeout = 30 * 1000);

        /// &lt;summary&gt;
        /// 响应
        /// &lt;/summary&gt;
        /// &lt;param name="handler"&gt;订阅方法&lt;/param&gt;
        void Answer(Func&lt;IMessage&lt;TSource&gt;, TResult&gt; handler);
    }
}</value>
    <comment>${SLN}$\${NR}$.Framework\RabbitMQ.Client\Roles\IRemoteProcedure`2.cs</comment>
  </data>
  <data name="Framework_System_Diagnostics_DailyErrorLogger_cs" xml:space="preserve">
    <value>using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace System.Diagnostics
{
    public class DailyErrorLogger : DailyLogger
    {
        private const string FolderName = "Error";

        public static readonly TraceEventType EventType = TraceEventType.Error;

        private string _folder;
        public override string Folder
        {
            get
            {
                if (_folder == null)
                    _folder = Path.Combine(base.Folder, FolderName);
                if (!Directory.Exists(_folder))
                    Directory.CreateDirectory(_folder);
                return _folder;
            }
            set =&gt; _folder = value;
        }

        public override void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, object data)
        {
            if (eventType != EventType) return;
            base.TraceData(eventCache, source, eventType, id, data);
        }
        public override void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, params object[] data)
        {
            if (eventType != EventType) return;
            base.TraceData(eventCache, source, eventType, id, data);
        }
        public override void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string message)
        {
            if (eventType != EventType) return;
            base.TraceEvent(eventCache, source, eventType, id, message);
        }
        public override void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string format, params object[] args)
        {
            if (eventType != EventType) return;
            base.TraceEvent(eventCache, source, eventType, id, format, args);
        }
    }
}</value>
    <comment>${SLN}$\${NR}$.Framework\System.Diagnostics\DailyErrorLogger.cs</comment>
  </data>
  <data name="Repositories_csproj" xml:space="preserve">
    <value>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003"&gt;
  &lt;Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" /&gt;
  &lt;PropertyGroup&gt;
    &lt;Configuration Condition=" '$(Configuration)' == '' "&gt;Debug&lt;/Configuration&gt;
    &lt;Platform Condition=" '$(Platform)' == '' "&gt;AnyCPU&lt;/Platform&gt;
    &lt;ProjectGuid&gt;{${RepositoriesProjectGuid}$}&lt;/ProjectGuid&gt;
    &lt;OutputType&gt;Library&lt;/OutputType&gt;
    &lt;AppDesignerFolder&gt;Properties&lt;/AppDesignerFolder&gt;
    &lt;RootNamespace&gt;${NR}$.Repositories&lt;/RootNamespace&gt;
    &lt;AssemblyName&gt;${NR}$.Repositories&lt;/AssemblyName&gt;
    &lt;TargetFrameworkVersion&gt;v4.6.1&lt;/TargetFrameworkVersion&gt;
    &lt;FileAlignment&gt;512&lt;/FileAlignment&gt;
    &lt;Deterministic&gt;true&lt;/Deterministic&gt;
    &lt;SccProjectName&gt;
    &lt;/SccProjectName&gt;
    &lt;SccLocalPath&gt;
    &lt;/SccLocalPath&gt;
    &lt;SccAuxPath&gt;
    &lt;/SccAuxPath&gt;
    &lt;SccProvider&gt;
    &lt;/SccProvider&gt;
  &lt;/PropertyGroup&gt;
  &lt;PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' "&gt;
    &lt;DebugSymbols&gt;true&lt;/DebugSymbols&gt;
    &lt;DebugType&gt;full&lt;/DebugType&gt;
    &lt;Optimize&gt;false&lt;/Optimize&gt;
    &lt;OutputPath&gt;bin\Debug\&lt;/OutputPath&gt;
    &lt;DefineConstants&gt;DEBUG;TRACE&lt;/DefineConstants&gt;
    &lt;ErrorReport&gt;prompt&lt;/ErrorReport&gt;
    &lt;WarningLevel&gt;4&lt;/WarningLevel&gt;
  &lt;/PropertyGroup&gt;
  &lt;PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' "&gt;
    &lt;DebugType&gt;pdbonly&lt;/DebugType&gt;
    &lt;Optimize&gt;true&lt;/Optimize&gt;
    &lt;OutputPath&gt;bin\Release\&lt;/OutputPath&gt;
    &lt;DefineConstants&gt;TRACE&lt;/DefineConstants&gt;
    &lt;ErrorReport&gt;prompt&lt;/ErrorReport&gt;
    &lt;WarningLevel&gt;4&lt;/WarningLevel&gt;
  &lt;/PropertyGroup&gt;
  &lt;ItemGroup&gt;
    &lt;Reference Include="Dapper, Version=2.0.0.0, Culture=neutral, processorArchitecture=MSIL"&gt;
      &lt;HintPath&gt;..\packages\Dapper.2.0.123\lib\net461\Dapper.dll&lt;/HintPath&gt;
    &lt;/Reference&gt;
    &lt;Reference Include="Dapper.Contrib, Version=2.0.0.0, Culture=neutral, processorArchitecture=MSIL"&gt;
      &lt;HintPath&gt;..\packages\Dapper.Contrib.2.0.78\lib\net461\Dapper.Contrib.dll&lt;/HintPath&gt;
    &lt;/Reference&gt;
    &lt;Reference Include="System" /&gt;
    &lt;Reference Include="System.Configuration" /&gt;
    &lt;Reference Include="System.Core" /&gt;
    &lt;Reference Include="System.Transactions" /&gt;
    &lt;Reference Include="System.Xml.Linq" /&gt;
    &lt;Reference Include="System.Data.DataSetExtensions" /&gt;
    &lt;Reference Include="Microsoft.CSharp" /&gt;
    &lt;Reference Include="System.Data" /&gt;
    &lt;Reference Include="System.Net.Http" /&gt;
    &lt;Reference Include="System.Xml" /&gt;
  &lt;/ItemGroup&gt;
  &lt;ItemGroup&gt;
    &lt;Compile Include="Base\BaseRepository.cs" /&gt;
    &lt;Compile Include="Base\BaseRepository`1.cs" /&gt;
    &lt;Compile Include="Base\ConnectionHolder.cs" /&gt;
    &lt;Compile Include="Base\ExpressionVisitor`1.cs" /&gt;
    &lt;Compile Include="Base\IRepository.cs" /&gt;
    &lt;Compile Include="Base\IRepository`1.cs" /&gt;
    &lt;Compile Include="Base\ParamNameMapper.cs" /&gt;
    &lt;Compile Include="Base\TableNameMapper.cs" /&gt;
    &lt;Compile Include="Properties\AssemblyInfo.cs" /&gt;
  &lt;/ItemGroup&gt;
  &lt;ItemGroup&gt;
    &lt;ProjectReference Include="..\${NR}$.Framework\${NR}$.Framework.csproj"&gt;
      &lt;Project&gt;{${FrameworkProjectGuid}$}&lt;/Project&gt;
      &lt;Name&gt;${NR}$.Framework&lt;/Name&gt;
    &lt;/ProjectReference&gt;
    &lt;ProjectReference Include="..\${NR}$.Models\${NR}$.Models.csproj"&gt;
      &lt;Project&gt;{${ModelsProjectGuid}$}&lt;/Project&gt;
      &lt;Name&gt;${NR}$.Models&lt;/Name&gt;
    &lt;/ProjectReference&gt;
  &lt;/ItemGroup&gt;
  &lt;ItemGroup&gt;
    &lt;None Include="app.config" /&gt;
    &lt;None Include="packages.config" /&gt;
  &lt;/ItemGroup&gt;
  &lt;Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" /&gt;
&lt;/Project&gt;</value>
    <comment>${SLN}$\${NR}$.Repositories\${NR}$.Repositories.csproj</comment>
  </data>
  <data name="Framework_System_Diagnostics_DailyInfoLogger_cs" xml:space="preserve">
    <value>using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace System.Diagnostics
{
    public class DailyInfoLogger : DailyLogger
    {
        private const string FolderName = "Info";

        public static readonly TraceEventType EventType = TraceEventType.Information;

        private string _folder;
        public override string Folder
        {
            get
            {
                if (_folder == null)
                    _folder = Path.Combine(base.Folder, FolderName);
                if (!Directory.Exists(_folder))
                    Directory.CreateDirectory(_folder);
                return _folder;
            }
            set =&gt; _folder = value;
        }

        public override void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, object data)
        {
            if (eventType != EventType) return;
            base.TraceData(eventCache, source, eventType, id, data);
        }
        public override void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, params object[] data)
        {
            if (eventType != EventType) return;
            base.TraceData(eventCache, source, eventType, id, data);
        }
        public override void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string message)
        {
            if (eventType != EventType) return;
            base.TraceEvent(eventCache, source, eventType, id, message);
        }
        public override void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string format, params object[] args)
        {
            if (eventType != EventType) return;
            base.TraceEvent(eventCache, source, eventType, id, format, args);
        }
    }
}</value>
    <comment>${SLN}$\${NR}$.Framework\System.Diagnostics\DailyInfoLogger.cs</comment>
  </data>
  <data name="Framework_System_Diagnostics_DailyLogger_cs" xml:space="preserve">
    <value>using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace System.Diagnostics
{
    public class DailyLogger : TraceListener
    {
        private const string FolderName = "log";

        private string _folder;
        private DateTime _day;
        private TextWriter _writer;

        public DailyLogger()
        {
            _folder = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, FolderName);
            _day = DateTime.Today;
            RefreshWriter();
        }

        public virtual string Folder
        {
            get
            {
                if (!Directory.Exists(_folder))
                    Directory.CreateDirectory(_folder);
                return _folder;
            }
            set =&gt; _folder = value;
        }

        public string FileName =&gt; $"{_day:yyyy-MM-dd}.log";

        public string FilePath =&gt; Path.Combine(Folder, FileName);

        public TextWriter Writer
        {
            get
            {
                if (_day &lt; DateTime.Today)
                    RefreshWriter();
                return _writer;
            }
            set =&gt; _writer = value;
        }

        private void RefreshWriter()
        {
            _writer?.Dispose();
            _day = DateTime.Today;
            if (!File.Exists(FilePath))
                using (File.Create(FilePath)) { }
            _writer = File.AppendText(FilePath);
        }

        public override void Write(string message)
        {
            Writer.Write(message);
            if (Trace.AutoFlush) Writer.Flush();
            Console.Write(message);
        }

        public override void WriteLine(string message)
        {
            Writer.WriteLine(message);
            if (Trace.AutoFlush) Writer.Flush();
            Console.WriteLine(message);
        }

        public override void WriteLine(object o)
        {
            if (Filter != null &amp;&amp; !Filter.ShouldTrace(null, "", TraceEventType.Verbose, 0, null, null, o, null))
                return;
            WriteLine(o == null ? "" : o.ToString());
        }

        public override void WriteLine(string message, string category)
        {
            if (Filter != null &amp;&amp; !Filter.ShouldTrace(null, "", TraceEventType.Verbose, 0, message, null, null, null))
                return;
            if (category == null)
                WriteLine(message);
            else
                WriteLine(category + ": " + (message ?? string.Empty));
        }

        public override void WriteLine(object o, string category)
        {
            if (Filter != null &amp;&amp; !Filter.ShouldTrace(null, "", TraceEventType.Verbose, 0, category, null, o, null))
                return;
            WriteLine(o == null ? "" : o.ToString(), category);
        }

        public override void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, object data)
        {
            if (Filter != null &amp;&amp; !Filter.ShouldTrace(eventCache, source, eventType, id, null, null, data, null))
                return;
            WriteHeader(source, eventType, id);
            string empty = string.Empty;
            if (data != null)
                empty = data.ToString();
            WriteLine(empty);
            WriteFooter(eventCache);
        }

        public override void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, params object[] data)
        {
            if (Filter != null &amp;&amp; !Filter.ShouldTrace(eventCache, source, eventType, id, null, null, null, data))
                return;
            WriteHeader(source, eventType, id);
            StringBuilder stringBuilder = new StringBuilder();
            if (data != null)
            {
                for (int index = 0; index &lt; data.Length; ++index)
                {
                    if (index != 0)
                        stringBuilder.Append(", ");
                    if (data[index] != null)
                        stringBuilder.Append(data[index].ToString());
                }
            }
            WriteLine(stringBuilder.ToString());
            WriteFooter(eventCache);
        }

        public override void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id)
        {
            TraceEvent(eventCache, source, eventType, id, string.Empty);
        }

        public override void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string message)
        {
            if (Filter != null &amp;&amp; !Filter.ShouldTrace(eventCache, source, eventType, id, message, null, null, null))
                return;
            WriteHeader(source, eventType, id);
            WriteLine(message);
            WriteFooter(eventCache);
        }

        public override void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string format, params object[] args)
        {
            if (Filter != null &amp;&amp; !Filter.ShouldTrace(eventCache, source, eventType, id, format, args, null, null))
                return;
            WriteHeader(source, eventType, id);
            if (args != null)
                WriteLine(string.Format(CultureInfo.InvariantCulture, format, args));
            else
                WriteLine(format);
            WriteFooter(eventCache);
        }

        public override void TraceTransfer(TraceEventCache eventCache, string source, int id, string message, Guid relatedActivityId)
        {
            TraceEvent(eventCache, source, TraceEventType.Transfer, id, message + ", relatedActivityId=" + relatedActivityId.ToString());
        }

        private void WriteHeader(string source, TraceEventType eventType, int id)
        {
            //Write($"[{eventType}][{DateTime.Now:HH:mm:ss}]: ");
            Write($"[{DateTime.Now:HH:mm:ss}]: ");
        }

        private void WriteFooter(TraceEventCache eventCache)
        {
            if (eventCache == null)
                return;
            if (IsEnabled(TraceOptions.ProcessId))
                WriteLine("ProcessId=" + eventCache.ProcessId);
            if (IsEnabled(TraceOptions.LogicalOperationStack))
            {
                Write("LogicalOperationStack=");
                Stack logicalOperationStack = eventCache.LogicalOperationStack;
                bool flag = true;
                foreach (object obj in logicalOperationStack)
                {
                    if (!flag)
                        Write(", ");
                    else
                        flag = false;
                    Write(obj.ToString());
                }
                WriteLine(string.Empty);
            }
            if (IsEnabled(TraceOptions.ThreadId))
                WriteLine("ThreadId=" + eventCache.ThreadId);
            if (IsEnabled(TraceOptions.DateTime))
                WriteLine("DateTime=" + eventCache.DateTime.ToString("o", CultureInfo.InvariantCulture));
            if (IsEnabled(TraceOptions.Timestamp))
                WriteLine("Timestamp=" + eventCache.Timestamp);
            if (IsEnabled(TraceOptions.Callstack))
                WriteLine("Callstack=" + eventCache.Callstack);
        }

        private bool IsEnabled(TraceOptions opts) =&gt; (opts &amp; TraceOutputOptions) != 0;

        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {
                _writer?.Dispose();
            }
            base.Dispose(disposing);
        }
    }
}</value>
    <comment>${SLN}$\${NR}$.Framework\System.Diagnostics\DailyLogger.cs</comment>
  </data>
  <data name="Framework_System_Diagnostics_Logger_cs" xml:space="preserve">
    <value>using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace System.Diagnostics
{
    public static class Logger
    {
        static Logger()
        {
            Trace.Listeners.Add(new DailyInfoLogger());
            Trace.Listeners.Add(new DailyErrorLogger());
            Trace.AutoFlush = true;
        }

        public static void Info(object info)
        {
            Trace.TraceInformation(info.ToString());
        }

        public static void Error(object error)
        {
            Trace.TraceError(error.ToString());
        }
    }
}</value>
    <comment>${SLN}$\${NR}$.Framework\System.Diagnostics\Logger.cs</comment>
  </data>
  <data name="Framework_app_config" xml:space="preserve">
    <value>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;configuration&gt;
  &lt;runtime&gt;
    &lt;assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1"&gt;
      &lt;dependentAssembly&gt;
        &lt;assemblyIdentity name="System.Threading.Tasks.Extensions" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" /&gt;
        &lt;bindingRedirect oldVersion="0.0.0.0-4.2.0.1" newVersion="4.2.0.1" /&gt;
      &lt;/dependentAssembly&gt;
    &lt;/assemblyBinding&gt;
  &lt;/runtime&gt;
&lt;/configuration&gt;</value>
    <comment>${SLN}$\${NR}$.Framework\app.config</comment>
  </data>
  <data name="Framework_AppSettings_cs" xml:space="preserve">
    <value>using System;
using System.Configuration;
using System.Linq;
using System.Reflection;
using System.Web;
using System.Web.Configuration;

namespace ${NR}$.Framework
{
    public class AppSettings
    {
        private Configuration OpenExeConfiguration()
        {
            if (HttpContext.Current != null &amp;&amp; !HttpContext.Current.Request.PhysicalPath.Equals(string.Empty))
                return WebConfigurationManager.OpenWebConfiguration("~");
            else
                return ConfigurationManager.OpenExeConfiguration(ConfigurationUserLevel.None);
        }

        private object ChangeType(object obj, Type type)
        {
            if (obj.GetType() == type) return obj;
            Type underlying = Nullable.GetUnderlyingType(type) ?? type;
            return Convert.ChangeType(obj, underlying);
        }

        public string Get(string key, string def = null)
        {
            Configuration config = OpenExeConfiguration();
            KeyValueConfigurationCollection settings = config.AppSettings.Settings;
            if (!settings.AllKeys.Contains(key))
            {
                settings.Add(key, def?.ToString());
                config.Save();
                ConfigurationManager.RefreshSection("appSettings");
            }
            return settings[key].Value;
        }

        public T Get&lt;T&gt;(string key, T def = default(T)) where T : struct
        {
            string value = Get(key, def.ToString());
            return (T)ChangeType(value, typeof(T));
        }

        public bool TryGet&lt;T&gt;(string key, out T result) where T : struct
        {
            string value = Get(key);
            if (string.IsNullOrWhiteSpace(value))
            {
                result = default(T);
                return false;
            }
            else
            {
                result = (T)ChangeType(value, typeof(T));
                return true;
            }
        }

        public void Set(string key, object value)
        {
            Configuration config = OpenExeConfiguration();
            KeyValueConfigurationCollection settings = config.AppSettings.Settings;
            if (settings.AllKeys.Contains(key))
                settings[key].Value = value.ToString();
            else
                settings.Add(key, value.ToString());
            config.Save();
            ConfigurationManager.RefreshSection("appSettings");
        }

        public T GetModel&lt;T&gt;() where T : class, new()
        {
            Configuration config = OpenExeConfiguration();
            KeyValueConfigurationCollection settings = config.AppSettings.Settings;
            PropertyInfo[] props = typeof(T).GetProperties();
            T model = new T();
            foreach (PropertyInfo prop in props)
            {
                if (settings.AllKeys.Contains(prop.Name))
                {
                    prop.SetValue(model, ChangeType(settings[prop.Name].Value, prop.PropertyType), null);
                }
            }
            return model;
        }

        public void SaveModel&lt;T&gt;(T model) where T : class
        {
            Configuration config = OpenExeConfiguration();
            KeyValueConfigurationCollection settings = config.AppSettings.Settings;
            PropertyInfo[] props = typeof(T).GetProperties();
            foreach (PropertyInfo prop in props)
            {
                if (!settings.AllKeys.Contains(prop.Name))
                    settings.Add(prop.Name, string.Empty);
                settings[prop.Name].Value = prop.GetValue(model)?.ToString() ?? string.Empty;
            }
            config.Save();
            ConfigurationManager.RefreshSection("appSettings");
        }
    }
}</value>
    <comment>${SLN}$\${NR}$.Framework\AppSettings.cs</comment>
  </data>
  <data name="Framework_CurrentUser_cs" xml:space="preserve">
    <value>using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Principal;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Web;

namespace ${NR}$.Framework
{
    public class CurrentUser
    {
        public static string LoginId
        {
            get
            {
                if (HttpContext.Current != null)
                    return HttpContext.Current.User?.Identity?.Name;
                else
                    return Thread.CurrentPrincipal.Identity.Name;
            }
            set
            {
                IPrincipal principal = new GenericPrincipal(new GenericIdentity(value), null);
                if (HttpContext.Current != null)
                    HttpContext.Current.User = principal;
                else
                    Thread.CurrentPrincipal = principal;
            }
        }
    }
}</value>
    <comment>${SLN}$\${NR}$.Framework\CurrentUser.cs</comment>
  </data>
  <data name="Framework_Database_cs" xml:space="preserve">
    <value>using System;
using System.Collections.Generic;
using System.Configuration;
using System.Data;
using System.Data.Common;
using System.Diagnostics.CodeAnalysis;
using System.Text.RegularExpressions;
using System.Transactions;

namespace ${NR}$.Framework
{
    [SuppressMessage("Security", "CA2100")]
    public class Database
    {
        protected const string DEFAULTUSERID = "timetrackpro";
        protected const string DEFAULTPASSWORD = "tp2000";

        private string _connectionString;

        public string ProviderName { get; set; }
        public string ConnectionString
        {
            get
            {
                if (Regex.IsMatch(_connectionString, nameof(DEFAULTUSERID), RegexOptions.IgnoreCase))
                {
                    _connectionString = Regex.Replace(_connectionString, nameof(DEFAULTUSERID), DEFAULTUSERID, RegexOptions.IgnoreCase);
                }
                if (Regex.IsMatch(_connectionString, nameof(DEFAULTPASSWORD), RegexOptions.IgnoreCase))
                {
                    _connectionString = Regex.Replace(_connectionString, nameof(DEFAULTPASSWORD), DEFAULTPASSWORD, RegexOptions.IgnoreCase);
                }
                return _connectionString;
            }
            set =&gt; _connectionString = value;
        }

        public Database() { }
        public Database(string name)
        {
            ConnectionStringSettings settings = ConfigurationManager.ConnectionStrings[name];
            ProviderName = settings.ProviderName;
            ConnectionString = settings.ConnectionString;
        }
        public static Database Default
        {
            get
            {
                string defaultName = ConfigurationManager.AppSettings.Get("DefaultConnection");
                if (!string.IsNullOrWhiteSpace(defaultName))
                {
                    return new Database(defaultName);
                }
                ConnectionStringSettings settings = ConfigurationManager.ConnectionStrings[ConfigurationManager.ConnectionStrings.Count - 1];
                return new Database
                {
                    ProviderName = settings.ProviderName,
                    ConnectionString = settings.ConnectionString
                };
            }
        }

        public DbProviderFactory GetProviderFactory()
        {
            return DbProviderFactories.GetFactory(ProviderName);
        }
        public DbConnection CreateConnection()
        {
            DbProviderFactory factory = GetProviderFactory();
            DbConnection conn = factory.CreateConnection();
            conn.ConnectionString = ConnectionString;
            return conn;
        }
        public DbConnection OpenConnection()
        {
            DbConnection conn = CreateConnection();
            conn.Open();
            return conn;
        }
        public DbCommand CreateCommand()
        {
            DbProviderFactory factory = GetProviderFactory();
            DbCommand dbCmd = factory.CreateCommand();
            dbCmd.CommandTimeout = int.TryParse(ConfigurationManager.AppSettings.Get("DbCommandTimeout"), out int timeout) ? timeout : 180;
            return dbCmd;
        }
        public DbParameter CreateParameter(string name, object value, DbType dbType, int size = 0, ParameterDirection direction = ParameterDirection.Input)
        {
            DbProviderFactory factory = GetProviderFactory();
            DbParameter para = factory.CreateParameter();
            para.Direction = direction;
            para.ParameterName = name;
            para.Value = value ?? DBNull.Value;
            para.DbType = dbType;
            para.Size = size;
            return para;
        }
        public DbCommand GetSqlStringCommand(string sql, DbConnection conn = null)
        {
            DbCommand dbCmd = CreateCommand();
            dbCmd.CommandType = CommandType.Text;
            dbCmd.CommandText = sql;
            dbCmd.Connection = conn;
            return dbCmd;
        }
        public DbCommand GetSqlStringCommand(string sql, params DbParameter[] parameters)
        {
            DbCommand dbCmd = CreateCommand();
            dbCmd.CommandText = sql;
            if (parameters != null &amp;&amp; parameters.Length &gt; 0)
            {
                dbCmd.Parameters.AddRange(parameters);
            }
            return dbCmd;
        }
        public DbCommand GetStoredProcCommand(string procedureName, DbConnection conn = null)
        {
            DbCommand dbCmd = CreateCommand();
            dbCmd.CommandType = CommandType.StoredProcedure;
            dbCmd.CommandText = procedureName;
            dbCmd.Connection = conn;
            return dbCmd;
        }
        public DbParameter AddParameter(DbCommand dbCmd, string name, object value, DbType dbType, int size, ParameterDirection direction)
        {
            DbParameter para = CreateParameter(name, value, dbType, size, direction);
            dbCmd.Parameters.Add(para);
            return para;
        }
        public void AddInParameter(DbCommand dbCmd, string name, object value, DbType dbType, int size = 0)
        {
            AddParameter(dbCmd, name, value, dbType, size, ParameterDirection.Input);
        }
        public DbParameter AddOutParameter(DbCommand dbCmd, string name, DbType dbType, int size = 0)
        {
            return AddParameter(dbCmd, name, null, dbType, size, ParameterDirection.Output);
        }
        public int ExecuteNonQuery(DbCommand dbCmd, DbTransaction tran = null)
        {
            using (new CommandWrapper(this, dbCmd, tran))
            {
                return dbCmd.ExecuteNonQuery();
            }
        }
        public int ExecuteNonQuery(string sql, params DbParameter[] parameters)
        {
            DbCommand dbCmd = GetSqlStringCommand(sql, parameters);
            return ExecuteNonQuery(dbCmd);
        }
        public DbDataReader ExecuteReader(DbCommand dbCmd)
        {
            using (new CommandWrapper(this, dbCmd, closeConn: false))
            {
                return dbCmd.ExecuteReader();
            }
        }
        public DbDataReader ExecuteReader(string sql, params DbParameter[] parameters)
        {
            DbCommand dbCmd = GetSqlStringCommand(sql, parameters);
            return ExecuteReader(dbCmd);
        }
        public DbDataReader ExecuteReader(DbCommand dbCmd, CommandBehavior behavior)
        {
            using (new CommandWrapper(this, dbCmd))
            {
                return dbCmd.ExecuteReader(behavior);
            }
        }
        public bool Exists(string sql, params DbParameter[] parameters)
        {
            using (DbDataReader reader = ExecuteReader(sql, parameters))
            {
                return reader.Read();
            }
        }
        public object ExecuteScalar(DbCommand dbCmd)
        {
            using (new CommandWrapper(this, dbCmd))
            {
                return dbCmd.ExecuteScalar();
            }
        }
        public object ExecuteScalar(string sql, params DbParameter[] parameters)
        {
            DbCommand dbCmd = GetSqlStringCommand(sql, parameters);
            return ExecuteScalar(dbCmd);
        }
        public T ExecuteScalar&lt;T&gt;(DbCommand dbCmd)
        {
            object scalar = ExecuteScalar(dbCmd);
            if (scalar != null &amp;&amp; scalar != DBNull.Value)
            {
                if (scalar is T equal)
                    return equal;
                else
                    return (T)Convert.ChangeType(scalar, Nullable.GetUnderlyingType(typeof(T)) ?? typeof(T));
            }
            return default(T);
        }
        public T ExecuteScalar&lt;T&gt;(string sql, params DbParameter[] parameters)
        {
            DbCommand dbCmd = GetSqlStringCommand(sql, parameters);
            return ExecuteScalar&lt;T&gt;(dbCmd);
        }
        public DataSet ExecuteDataSet(DbCommand dbCmd)
        {
            using (new CommandWrapper(this, dbCmd))
            {
                DbProviderFactory factory = GetProviderFactory();
                DbDataAdapter dbAdapter = factory.CreateDataAdapter();
                DataSet ds = new DataSet();
                dbAdapter.SelectCommand = dbCmd;
                dbAdapter.SelectCommand.CommandTimeout = 180;
                dbAdapter.Fill(ds);
                return ds;
            }
        }
        public DataSet ExecuteDataSet(string sql, params DbParameter[] parameters)
        {
            DbCommand dbCmd = GetSqlStringCommand(sql, parameters);
            return ExecuteDataSet(dbCmd);
        }
        public DataTable ExecuteDataTable(DbCommand dbCmd, int tableIndex = 0)
        {
            DataSet ds = ExecuteDataSet(dbCmd);
            if (ds != null &amp;&amp; ds.Tables != null &amp;&amp; ds.Tables.Count &gt; tableIndex)
            {
                return ds.Tables[tableIndex];
            }
            return null;
        }
        public DataTable ExecuteDataTable(string sql, params DbParameter[] parameters)
        {
            DbCommand dbCmd = GetSqlStringCommand(sql, parameters);
            return ExecuteDataTable(dbCmd);
        }
        public DataTable ExecutePagedTable(DbCommand dbCmd, out int total, string orderBy, int pageNum = 1, int pageSize = 10)
        {
            dbCmd.CommandText = $@"
SELECT *
     , ROW_NUMBER() OVER (ORDER BY {orderBy}) rn
  INTO #__TEMP
  FROM (
      {dbCmd.CommandText}
  ) __TEMP;

SELECT @__total = COUNT(1)
  FROM #__TEMP;

SELECT *
  FROM #__TEMP
 WHERE rn BETWEEN @__begin AND @__end;
";
            AddInParameter(dbCmd, "__begin", (pageNum - 1) * pageSize + 1, DbType.Int32);
            AddInParameter(dbCmd, "__end", pageNum * pageSize, DbType.Int32);
            DbParameter paraTotal = AddOutParameter(dbCmd, "__total", DbType.Int32);
            DataTable table = ExecuteDataTable(dbCmd);
            total = paraTotal.Value is int ttl ? ttl : 0;
            return table;
        }
        public class CommandWrapper : IDisposable
        {

            private readonly DbCommand _dbCmd;
            private readonly bool _needClose;
            public CommandWrapper(Database db, DbCommand dbCmd, DbTransaction tran = null, bool? closeConn = null)
            {
                _dbCmd = dbCmd;
                if (tran != null)
                {
                    _dbCmd.Transaction = tran;
                    _dbCmd.Connection = tran.Connection;
                }
                else if (_dbCmd.Connection == null)
                {
                    if (Transaction.Current != null)
                    {
                        _dbCmd.Connection = TransactionScopeConnections.GetTransactionConnection(db);
                    }
                    else
                    {
                        _dbCmd.Connection = db.CreateConnection();
                        _needClose = true;
                    }
                }
                if (_dbCmd.Connection.State == ConnectionState.Closed)
                {
                    _dbCmd.Connection.Open();
                }
                if (closeConn.HasValue)
                {
                    _needClose = closeConn.Value;
                }
            }
            protected virtual void Dispose(bool disposing)
            {
                if (disposing)
                {
                    if (_needClose)
                    {
                        _dbCmd.Connection.Dispose();
                    }
                    _dbCmd.Parameters.Clear();
                    // ...
                }
                // ...
            }
            public void Dispose()
            {
                Dispose(true);
                GC.SuppressFinalize(this);
            }
        }
        public class TransactionScopeConnections
        {
            private static readonly Dictionary&lt;string, DbConnection&gt; _transactionConncetionPool = new Dictionary&lt;string, DbConnection&gt;();
            public static DbConnection GetTransactionConnection(Database db)
            {
                if (Transaction.Current == null) return null;
                string id = Transaction.Current.TransactionInformation.LocalIdentifier;
                lock (_transactionConncetionPool)
                {
                    if (!_transactionConncetionPool.ContainsKey(id) || _transactionConncetionPool[id] == null)
                    {
                        _transactionConncetionPool[id] = db.CreateConnection();
                        Transaction.Current.TransactionCompleted += Current_TransactionCompleted;
                    }
                    return _transactionConncetionPool[id];
                }
            }
            private static void Current_TransactionCompleted(object sender, TransactionEventArgs e)
            {
                string id = e.Transaction.TransactionInformation.LocalIdentifier;
                lock (_transactionConncetionPool)
                {
                    if (_transactionConncetionPool.ContainsKey(id))
                    {
                        _transactionConncetionPool[id]?.Dispose();
                        _transactionConncetionPool.Remove(id);
                    }
                }
            }
        }
    }
}</value>
    <comment>${SLN}$\${NR}$.Framework\Database.cs</comment>
  </data>
  <data name="Framework_EnumerableExtensions_cs" xml:space="preserve">
    <value>using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ${NR}$.Framework
{
    public static class EnumerableExtensions
    {
        public static void ForEach&lt;T&gt;(this IEnumerable&lt;T&gt; source, Action&lt;T&gt; action)
        {
            foreach (var element in source)
            {
                action(element);
            }
        }

        public static void ForEach&lt;T&gt;(this IEnumerable&lt;T&gt; source, Action&lt;T, int&gt; action)
        {
            int index = 0;
            foreach (var element in source)
            {
                action(element, index);
                index++;
            }
        }

        public static int FindIndex&lt;T&gt;(this IEnumerable&lt;T&gt; source, Func&lt;T, bool&gt; predicate)
        {
            if (source is List&lt;T&gt; list) return list.FindIndex(predicate);
            for (int i = 0; i &lt; source.Count(); i++)
            {
                T element = source.ElementAt(i);
                if (predicate(element))
                {
                    return i;
                }
            }
            return -1;
        }
    }
}</value>
    <comment>${SLN}$\${NR}$.Framework\EnumerableExtensions.cs</comment>
  </data>
  <data name="Framework_packages_config" xml:space="preserve">
    <value>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;packages&gt;
  &lt;package id="Newtonsoft.Json" version="13.0.1" targetFramework="net461" /&gt;
  &lt;package id="RabbitMQ.Client" version="6.4.0" targetFramework="net461" /&gt;
  &lt;package id="System.Buffers" version="4.5.1" targetFramework="net461" /&gt;
  &lt;package id="System.Memory" version="4.5.4" targetFramework="net461" /&gt;
  &lt;package id="System.Numerics.Vectors" version="4.5.0" targetFramework="net461" /&gt;
  &lt;package id="System.Runtime.CompilerServices.Unsafe" version="4.5.3" targetFramework="net461" /&gt;
  &lt;package id="System.Threading.Channels" version="4.7.1" targetFramework="net461" /&gt;
  &lt;package id="System.Threading.Tasks.Extensions" version="4.5.4" targetFramework="net461" /&gt;
&lt;/packages&gt;</value>
    <comment>${SLN}$\${NR}$.Framework\packages.config</comment>
  </data>
  <data name="Models_AutoMapper_MapperConfig_cs" xml:space="preserve">
    <value>using AutoMapper;
using AutoMapper.Attributes;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;

namespace ${NR}$.Models
{
    public static class MapperConfig
    {
        public static MapperConfiguration MapperConfiguration { get; set; }
        public static IMapper Mapper { get; set; }

        static MapperConfig()
        {
            MapperConfiguration = new MapperConfiguration(cfg =&gt;
            {
                typeof(MapperConfig).GetTypeInfo().Assembly.MapTypes(cfg);
            });

            Mapper = MapperConfiguration.CreateMapper();
        }

        public static T Map&lt;T&gt;(this object obj)
        {
            return Mapper.Map&lt;T&gt;(obj);
        }
    }
}</value>
    <comment>${SLN}$\${NR}$.Models\AutoMapper\MapperConfig.cs</comment>
  </data>
  <data name="Services_csproj" xml:space="preserve">
    <value>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003"&gt;
  &lt;Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" /&gt;
  &lt;PropertyGroup&gt;
    &lt;Configuration Condition=" '$(Configuration)' == '' "&gt;Debug&lt;/Configuration&gt;
    &lt;Platform Condition=" '$(Platform)' == '' "&gt;AnyCPU&lt;/Platform&gt;
    &lt;ProjectGuid&gt;{${ServicesProjectGuid}$}&lt;/ProjectGuid&gt;
    &lt;OutputType&gt;Library&lt;/OutputType&gt;
    &lt;AppDesignerFolder&gt;Properties&lt;/AppDesignerFolder&gt;
    &lt;RootNamespace&gt;${NR}$.Services&lt;/RootNamespace&gt;
    &lt;AssemblyName&gt;${NR}$.Services&lt;/AssemblyName&gt;
    &lt;TargetFrameworkVersion&gt;v4.6.1&lt;/TargetFrameworkVersion&gt;
    &lt;FileAlignment&gt;512&lt;/FileAlignment&gt;
    &lt;Deterministic&gt;true&lt;/Deterministic&gt;
    &lt;SccProjectName&gt;
    &lt;/SccProjectName&gt;
    &lt;SccLocalPath&gt;
    &lt;/SccLocalPath&gt;
    &lt;SccAuxPath&gt;
    &lt;/SccAuxPath&gt;
    &lt;SccProvider&gt;
    &lt;/SccProvider&gt;
  &lt;/PropertyGroup&gt;
  &lt;PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' "&gt;
    &lt;DebugSymbols&gt;true&lt;/DebugSymbols&gt;
    &lt;DebugType&gt;full&lt;/DebugType&gt;
    &lt;Optimize&gt;false&lt;/Optimize&gt;
    &lt;OutputPath&gt;bin\Debug\&lt;/OutputPath&gt;
    &lt;DefineConstants&gt;DEBUG;TRACE&lt;/DefineConstants&gt;
    &lt;ErrorReport&gt;prompt&lt;/ErrorReport&gt;
    &lt;WarningLevel&gt;4&lt;/WarningLevel&gt;
  &lt;/PropertyGroup&gt;
  &lt;PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' "&gt;
    &lt;DebugType&gt;pdbonly&lt;/DebugType&gt;
    &lt;Optimize&gt;true&lt;/Optimize&gt;
    &lt;OutputPath&gt;bin\Release\&lt;/OutputPath&gt;
    &lt;DefineConstants&gt;TRACE&lt;/DefineConstants&gt;
    &lt;ErrorReport&gt;prompt&lt;/ErrorReport&gt;
    &lt;WarningLevel&gt;4&lt;/WarningLevel&gt;
  &lt;/PropertyGroup&gt;
  &lt;ItemGroup&gt;
    &lt;Reference Include="System" /&gt;
    &lt;Reference Include="System.Configuration" /&gt;
    &lt;Reference Include="System.Core" /&gt;
    &lt;Reference Include="System.Transactions" /&gt;
    &lt;Reference Include="System.Xml.Linq" /&gt;
    &lt;Reference Include="System.Data.DataSetExtensions" /&gt;
    &lt;Reference Include="Microsoft.CSharp" /&gt;
    &lt;Reference Include="System.Data" /&gt;
    &lt;Reference Include="System.Net.Http" /&gt;
    &lt;Reference Include="System.Xml" /&gt;
  &lt;/ItemGroup&gt;
  &lt;ItemGroup&gt;
    &lt;Compile Include="Base\BaseService.cs" /&gt;
    &lt;Compile Include="Base\IService.cs" /&gt;
    &lt;Compile Include="Properties\AssemblyInfo.cs" /&gt;
  &lt;/ItemGroup&gt;
  &lt;ItemGroup&gt;
    &lt;ProjectReference Include="..\${NR}$.Framework\${NR}$.Framework.csproj"&gt;
      &lt;Project&gt;{${FrameworkProjectGuid}$}&lt;/Project&gt;
      &lt;Name&gt;${NR}$.Framework&lt;/Name&gt;
    &lt;/ProjectReference&gt;
    &lt;ProjectReference Include="..\${NR}$.Models\${NR}$.Models.csproj"&gt;
      &lt;Project&gt;{${ModelsProjectGuid}$}&lt;/Project&gt;
      &lt;Name&gt;${NR}$.Models&lt;/Name&gt;
    &lt;/ProjectReference&gt;
    &lt;ProjectReference Include="..\${NR}$.Repositories\${NR}$.Repositories.csproj"&gt;
      &lt;Project&gt;{${RepositoriesProjectGuid}$}&lt;/Project&gt;
      &lt;Name&gt;${NR}$.Repositories&lt;/Name&gt;
    &lt;/ProjectReference&gt;
  &lt;/ItemGroup&gt;
  &lt;Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" /&gt;
&lt;/Project&gt;</value>
    <comment>${SLN}$\${NR}$.Services\${NR}$.Services.csproj</comment>
  </data>
  <data name="Models_Base_BaseModel_cs" xml:space="preserve">
    <value>using System;

namespace ${NR}$.Models
{
    public class BaseModel : IModel
    {
    }
}</value>
    <comment>${SLN}$\${NR}$.Models\Base\BaseModel.cs</comment>
  </data>
  <data name="Models_Base_IAuditModel_cs" xml:space="preserve">
    <value>using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ${NR}$.Models
{
    public interface IAuditModel
    {
        DateTime? CreateDate { get; set; }
        string CreateUser { get; set; }
        DateTime? LastUpdateDate { get; set; }
        string LastUpdateUser { get; set; }
    }
}</value>
    <comment>${SLN}$\${NR}$.Models\Base\IAuditModel.cs</comment>
  </data>
  <data name="Models_Base_IIdentityModel_cs" xml:space="preserve">
    <value>using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ${NR}$.Models
{
    public interface IIdentityModel
    {
        int ID { get; set; }
    }
}</value>
    <comment>${SLN}$\${NR}$.Models\Base\IIdentityModel.cs</comment>
  </data>
  <data name="Models_Base_IIdentityModel_1_cs" xml:space="preserve">
    <value>using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ${NR}$.Models
{
    public interface IIdentityModel&lt;T&gt; where T : struct
    {
        T ID { get; set; }
    }
}</value>
    <comment>${SLN}$\${NR}$.Models\Base\IIdentityModel`1.cs</comment>
  </data>
  <data name="Models_Base_IModel_cs" xml:space="preserve">
    <value>using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ${NR}$.Models
{
    public interface IModel
    {
    }
}</value>
    <comment>${SLN}$\${NR}$.Models\Base\IModel.cs</comment>
  </data>
  <data name="Models_Base_PaggedOutput_cs" xml:space="preserve">
    <value>using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ${NR}$.Models
{
    public class PaggedOutput&lt;T&gt;
    {
        [JsonProperty("total")]
        public int Total { get; set; }

        [JsonProperty("rows")]
        public List&lt;T&gt; Rows { get; set; }
    }
}</value>
    <comment>${SLN}$\${NR}$.Models\Base\PaggedOutput.cs</comment>
  </data>
  <data name="Models_Properties_AssemblyInfo_cs" xml:space="preserve">
    <value>using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// 有关程序集的一般信息由以下
// 控制。更改这些特性值可修改
// 与程序集关联的信息。
[assembly: AssemblyTitle("${NR}$.Models")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("${NR}$.Models")]
[assembly: AssemblyCopyright("Copyright ©  2022")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// 将 ComVisible 设置为 false 会使此程序集中的类型
//对 COM 组件不可见。如果需要从 COM 访问此程序集中的类型
//请将此类型的 ComVisible 特性设置为 true。
[assembly: ComVisible(false)]

// 如果此项目向 COM 公开，则下列 GUID 用于类型库的 ID
[assembly: Guid("${ModelsProjectGuid}$")]

// 程序集的版本信息由下列四个值组成: 
//
//      主版本
//      次版本
//      生成号
//      修订号
//
// 可以指定所有值，也可以使用以下所示的 "*" 预置版本号和修订号
//通过使用 "*"，如下所示:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]</value>
    <comment>${SLN}$\${NR}$.Models\Properties\AssemblyInfo.cs</comment>
  </data>
  <data name="Models_app_config" xml:space="preserve">
    <value>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;configuration&gt;
  &lt;runtime&gt;
    &lt;assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1"&gt;
      &lt;dependentAssembly&gt;
        &lt;assemblyIdentity name="System.Threading.Tasks.Extensions" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" /&gt;
        &lt;bindingRedirect oldVersion="0.0.0.0-4.2.0.1" newVersion="4.2.0.1" /&gt;
      &lt;/dependentAssembly&gt;
    &lt;/assemblyBinding&gt;
  &lt;/runtime&gt;
&lt;/configuration&gt;</value>
    <comment>${SLN}$\${NR}$.Models\app.config</comment>
  </data>
  <data name="Models_Manager_ttinclude" xml:space="preserve">
    <value>&lt;#@ assembly name="System.Core"
#&gt;&lt;#@ assembly name="System.Data.Linq"
#&gt;&lt;#@ assembly name="EnvDTE"
#&gt;&lt;#@ assembly name="System.Xml"
#&gt;&lt;#@ assembly name="System.Xml.Linq"
#&gt;&lt;#@ import namespace="System"
#&gt;&lt;#@ import namespace="System.CodeDom"
#&gt;&lt;#@ import namespace="System.CodeDom.Compiler"
#&gt;&lt;#@ import namespace="System.Collections.Generic"
#&gt;&lt;#@ import namespace="System.Data.Linq"
#&gt;&lt;#@ import namespace="System.Data.Linq.Mapping"
#&gt;&lt;#@ import namespace="System.IO"
#&gt;&lt;#@ import namespace="System.Linq"
#&gt;&lt;#@ import namespace="System.Reflection"
#&gt;&lt;#@ import namespace="System.Text"
#&gt;&lt;#@ import namespace="System.Xml.Linq"
#&gt;&lt;#@ import namespace="Microsoft.VisualStudio.TextTemplating"
#&gt;&lt;#+


// Manager class records the various blocks so it can split them up
class Manager {
    private class Block {
        public String Name;
        public int Start, Length;
        public bool IncludeInDefault;
    }

    private Block currentBlock;
    private List&lt;Block&gt; files = new List&lt;Block&gt;();
    private Block footer = new Block();
    private Block header = new Block();
    private ITextTemplatingEngineHost host;
    private StringBuilder template;
    protected List&lt;String&gt; generatedFileNames = new List&lt;String&gt;();

    public static Manager Create(ITextTemplatingEngineHost host, StringBuilder template) {
        return (host is IServiceProvider) ? new VSManager(host, template) : new Manager(host, template);
    }

    public void StartNewFile(String name) {
        if (name == null)
            throw new ArgumentNullException("name");
        CurrentBlock = new Block { Name = name };
    }

    public void StartFooter(bool includeInDefault = true) {
        CurrentBlock = footer;
        footer.IncludeInDefault = includeInDefault;
    }

    public void StartHeader(bool includeInDefault = true) {
        CurrentBlock = header;
        header.IncludeInDefault = includeInDefault;
    }

    public void EndBlock() {
        if (CurrentBlock == null)
            return;
        CurrentBlock.Length = template.Length - CurrentBlock.Start;
        if (CurrentBlock != header &amp;&amp; CurrentBlock != footer)
            files.Add(CurrentBlock);
        currentBlock = null;
    }

    public virtual void Process(bool split, bool sync = true) {
        if (split) {
            EndBlock();
            String headerText = template.ToString(header.Start, header.Length);
            String footerText = template.ToString(footer.Start, footer.Length);
            String outputPath = Path.GetDirectoryName(host.TemplateFile);
            files.Reverse();
            if (!footer.IncludeInDefault)
                template.Remove(footer.Start, footer.Length);
            foreach(Block block in files) {
                String fileName = Path.Combine(outputPath, block.Name);
                String content = headerText + template.ToString(block.Start, block.Length) + footerText;
                generatedFileNames.Add(fileName);
                CreateFile(fileName, content);
                template.Remove(block.Start, block.Length);
            }
            if (!header.IncludeInDefault)
                template.Remove(header.Start, header.Length);
        }
    }

    protected virtual void CreateFile(String fileName, String content) {
        if (IsFileContentDifferent(fileName, content))
            File.WriteAllText(fileName, content);
    }

    public virtual String GetCustomToolNamespace(String fileName) {
        return null;
    }

    public virtual String DefaultProjectNamespace {
        get { return null; }
    }

    protected bool IsFileContentDifferent(String fileName, String newContent) {
        return !(File.Exists(fileName) &amp;&amp; File.ReadAllText(fileName) == newContent);
    }

    private Manager(ITextTemplatingEngineHost host, StringBuilder template) {
        this.host = host;
        this.template = template;
    }

    private Block CurrentBlock {
        get { return currentBlock; }
        set {
            if (CurrentBlock != null)
                EndBlock();
            if (value != null)
                value.Start = template.Length;
            currentBlock = value;
        }
    }

    private class VSManager: Manager {
        private EnvDTE.ProjectItem templateProjectItem;
        private EnvDTE.DTE dte;
        private Action&lt;String&gt; checkOutAction;
        private Action&lt;IEnumerable&lt;String&gt;&gt; projectSyncAction;

        public override String DefaultProjectNamespace {
            get {
                return templateProjectItem.ContainingProject.Properties.Item("DefaultNamespace").Value.ToString();
            }
        }

        public override String GetCustomToolNamespace(string fileName) {
            return dte.Solution.FindProjectItem(fileName).Properties.Item("CustomToolNamespace").Value.ToString();
        }

        public override void Process(bool split, bool sync) {
            if (templateProjectItem.ProjectItems == null)
                return;
            base.Process(split, sync);
            if (sync)
                projectSyncAction.EndInvoke(projectSyncAction.BeginInvoke(generatedFileNames, null, null));
        }

        protected override void CreateFile(String fileName, String content) {
            if (IsFileContentDifferent(fileName, content)) {
                CheckoutFileIfRequired(fileName);
                File.WriteAllText(fileName, content);
            }
        }

        internal VSManager(ITextTemplatingEngineHost host, StringBuilder template)
            : base(host, template) {
            var hostServiceProvider = (IServiceProvider) host;
            if (hostServiceProvider == null)
                throw new ArgumentNullException("Could not obtain IServiceProvider");
            dte = (EnvDTE.DTE) hostServiceProvider.GetService(typeof(EnvDTE.DTE));
            if (dte == null)
                throw new ArgumentNullException("Could not obtain DTE from host");
            templateProjectItem = dte.Solution.FindProjectItem(host.TemplateFile);
            checkOutAction = (String fileName) =&gt; dte.SourceControl.CheckOutItem(fileName);
            projectSyncAction = (IEnumerable&lt;String&gt; keepFileNames) =&gt; ProjectSync(templateProjectItem, keepFileNames);
        }

        private static void ProjectSync(EnvDTE.ProjectItem templateProjectItem, IEnumerable&lt;String&gt; keepFileNames) {
            var keepFileNameSet = new HashSet&lt;String&gt;(keepFileNames);
            var projectFiles = new Dictionary&lt;String, EnvDTE.ProjectItem&gt;();
            var originalFilePrefix = Path.GetFileNameWithoutExtension(templateProjectItem.get_FileNames(0)) + ".";
            foreach(EnvDTE.ProjectItem projectItem in templateProjectItem.ProjectItems)
                projectFiles.Add(projectItem.get_FileNames(0), projectItem);

            // Remove unused items from the project
            foreach(var pair in projectFiles)
                if (!keepFileNames.Contains(pair.Key) &amp;&amp; !(Path.GetFileNameWithoutExtension(pair.Key) + ".").StartsWith(originalFilePrefix))
                    pair.Value.Delete();

            // Add missing files to the project
            foreach(String fileName in keepFileNameSet)
                if (!projectFiles.ContainsKey(fileName))
                    templateProjectItem.ProjectItems.AddFromFile(fileName);
        }

        private void CheckoutFileIfRequired(String fileName) {
            var sc = dte.SourceControl;
            if (sc != null &amp;&amp; sc.IsItemUnderSCC(fileName) &amp;&amp; !sc.IsItemCheckedOut(fileName))
                checkOutAction.EndInvoke(checkOutAction.BeginInvoke(fileName, null, null));
        }
    }
} #&gt;</value>
    <comment>${SLN}$\${NR}$.Models\Manager.ttinclude</comment>
  </data>
  <data name="Debug_csproj" xml:space="preserve">
    <value>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003"&gt;
  &lt;Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" /&gt;
  &lt;PropertyGroup&gt;
    &lt;Configuration Condition=" '$(Configuration)' == '' "&gt;Debug&lt;/Configuration&gt;
    &lt;Platform Condition=" '$(Platform)' == '' "&gt;AnyCPU&lt;/Platform&gt;
    &lt;ProjectGuid&gt;{${DebugProjectGuid}$}&lt;/ProjectGuid&gt;
    &lt;OutputType&gt;Exe&lt;/OutputType&gt;
    &lt;RootNamespace&gt;${NR}$.Debug&lt;/RootNamespace&gt;
    &lt;AssemblyName&gt;${NR}$.Debug&lt;/AssemblyName&gt;
    &lt;TargetFrameworkVersion&gt;v4.6.1&lt;/TargetFrameworkVersion&gt;
    &lt;FileAlignment&gt;512&lt;/FileAlignment&gt;
    &lt;AutoGenerateBindingRedirects&gt;true&lt;/AutoGenerateBindingRedirects&gt;
    &lt;Deterministic&gt;true&lt;/Deterministic&gt;
  &lt;/PropertyGroup&gt;
  &lt;PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' "&gt;
    &lt;PlatformTarget&gt;AnyCPU&lt;/PlatformTarget&gt;
    &lt;DebugSymbols&gt;true&lt;/DebugSymbols&gt;
    &lt;DebugType&gt;full&lt;/DebugType&gt;
    &lt;Optimize&gt;false&lt;/Optimize&gt;
    &lt;OutputPath&gt;bin\Debug\&lt;/OutputPath&gt;
    &lt;DefineConstants&gt;DEBUG;TRACE&lt;/DefineConstants&gt;
    &lt;ErrorReport&gt;prompt&lt;/ErrorReport&gt;
    &lt;WarningLevel&gt;4&lt;/WarningLevel&gt;
  &lt;/PropertyGroup&gt;
  &lt;PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' "&gt;
    &lt;PlatformTarget&gt;AnyCPU&lt;/PlatformTarget&gt;
    &lt;DebugType&gt;pdbonly&lt;/DebugType&gt;
    &lt;Optimize&gt;true&lt;/Optimize&gt;
    &lt;OutputPath&gt;bin\Release\&lt;/OutputPath&gt;
    &lt;DefineConstants&gt;TRACE&lt;/DefineConstants&gt;
    &lt;ErrorReport&gt;prompt&lt;/ErrorReport&gt;
    &lt;WarningLevel&gt;4&lt;/WarningLevel&gt;
  &lt;/PropertyGroup&gt;
  &lt;ItemGroup&gt;
    &lt;Reference Include="System" /&gt;
    &lt;Reference Include="System.Core" /&gt;
    &lt;Reference Include="System.Xml.Linq" /&gt;
    &lt;Reference Include="System.Data.DataSetExtensions" /&gt;
    &lt;Reference Include="Microsoft.CSharp" /&gt;
    &lt;Reference Include="System.Data" /&gt;
    &lt;Reference Include="System.Net.Http" /&gt;
    &lt;Reference Include="System.Xml" /&gt;
  &lt;/ItemGroup&gt;
  &lt;ItemGroup&gt;
    &lt;Compile Include="Program.cs" /&gt;
    &lt;Compile Include="Properties\AssemblyInfo.cs" /&gt;
  &lt;/ItemGroup&gt;
  &lt;ItemGroup&gt;
    &lt;None Include="App.config" /&gt;
  &lt;/ItemGroup&gt;
  &lt;ItemGroup&gt;
    &lt;ProjectReference Include="..\${NR}$.Framework\${NR}$.Framework.csproj"&gt;
      &lt;Project&gt;{${FrameworkProjectGuid}$}&lt;/Project&gt;
      &lt;Name&gt;${NR}$.Framework&lt;/Name&gt;
    &lt;/ProjectReference&gt;
    &lt;ProjectReference Include="..\${NR}$.Models\${NR}$.Models.csproj"&gt;
      &lt;Project&gt;{${ModelsProjectGuid}$}&lt;/Project&gt;
      &lt;Name&gt;${NR}$.Models&lt;/Name&gt;
    &lt;/ProjectReference&gt;
    &lt;ProjectReference Include="..\${NR}$.Services\${NR}$.Services.csproj"&gt;
      &lt;Project&gt;{${ServicesProjectGuid}$}&lt;/Project&gt;
      &lt;Name&gt;${NR}$.Services&lt;/Name&gt;
    &lt;/ProjectReference&gt;
  &lt;/ItemGroup&gt;
  &lt;Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" /&gt;
&lt;/Project&gt;</value>
    <comment>${SLN}$\${NR}$.Debug\${NR}$.Debug.csproj</comment>
  </data>
  <data name="Models_Models_tt" xml:space="preserve">
    <value>&lt;#@ template debug="true" hostspecific="true" language="C#" #&gt;
&lt;#@ assembly name="System.Data" #&gt;
&lt;#@ assembly name="System.xml" #&gt;
&lt;#@ import namespace="System.Collections.Generic" #&gt;
&lt;#@ import namespace="System.Data.SqlClient" #&gt;
&lt;#@ import namespace="System.Data" #&gt;
&lt;#@ assembly name="System.Core" #&gt;
&lt;#@ import namespace="System.Linq" #&gt;
&lt;#@ include file="$(ProjectDir)Manager.ttinclude" #&gt;
&lt;#@ output extension="/" #&gt;

&lt;#    
   
        string connectionString= "${CONN}$";        
        SqlConnection conn = new SqlConnection(connectionString);
        conn.Open();
    
        string selectQuery ="SET FMTONLY ON; select * from @tableName; SET FMTONLY OFF;";
        SqlCommand command = new SqlCommand(selectQuery,conn);
        SqlDataAdapter ad = new SqlDataAdapter(command);
        System.Data.DataSet ds = new DataSet(); 
  
        var manager = Manager.Create(Host, GenerationEnvironment);  


        System.Data.DataTable schema = conn.GetSchema("Tables");
        foreach(System.Data.DataRow row in schema.Rows)
        {    
            ds.Tables.Clear();
            string tb_name= row["TABLE_NAME"].ToString();        
            command.CommandText = selectQuery.Replace("@tableName",row["TABLE_NAME"].ToString());
            ad.FillSchema(ds, SchemaType.Mapped,tb_name);  


            manager.StartNewFile(tb_name+".cs");#&gt;
using System;

namespace Se.Models
{    
	/// &lt;summary&gt;
	/// 实体-&lt;#=tb_name#&gt;
	/// &lt;/summary&gt;
	public partial class &lt;#=tb_name#&gt; : BaseModel&lt;#=ds.Tables[0].Columns.Contains("CreateDate")&amp;&amp;ds.Tables[0].Columns.Contains("UpdateDate")?", IAuditModel":""#&gt;&lt;#=ds.Tables[0].Columns.Contains("ID")&amp;&amp;ds.Tables[0].Columns["ID"].DataType==typeof(int)?", IIdentityModel":""#&gt;
	{
        &lt;# PushIndent(" ");
        foreach (DataColumn dc in ds.Tables[0].Columns)
        {
   //根据表名称和字段名称查出字段描述 comment
    string sql = @"select d.value from  sys.syscolumns a left outer join  sys.extended_properties  d on a.id = d.major_id and a.colid = d.minor_id and d.name = 'MS_Description' where object_name(a.id) = '{0}' and a.name='{1}'  ";
        SqlCommand cmd = new SqlCommand(string.Format(sql, row["TABLE_NAME"],dc.ColumnName),conn);
        object comment= cmd.ExecuteScalar();
        WriteLine("\r\n       /// &lt;summary&gt;\r\n       /// "+comment+"\r\n       /// &lt;/summary&gt;\r\n       public " + dc.DataType.Name+ (dc.AllowDBNull &amp;&amp; dc.DataType.Name.ToLower() != "string" &amp;&amp; !dc.DataType.Name.EndsWith("[]") ? "? ": " ") + dc.ColumnName + " { get; set; }");
        }

   //查询一个表的信息  当前表的所有字段,字段中没有查自增健
   string files = "select   a.name, a.isnullable, a.iscomputed,case when d.value is null then a.name else d.value end as comment, type_name(a.xusertype) as type, a.length, case when (a.status &amp; 0x80) = 0x80 then 1 else 0 end as is_identity, case when index_col (OBJECT_NAME(a.id), b.indid, a.colid) = a.name then 1 else 0 end  as is_primary, case when ( TYPE_NAME(a.xusertype) IN ('xml','text','ntext','image') OR (TYPE_NAME(a.xusertype) IN ('varchar','nvarchar','varbinary') AND a.length = -1) ) then 1 else 0 end as is_lob, case when ( c.ctext is null ) then 'null' else substring(c.text, 2, len(c.text) - 2 ) end as defaultValue from  sys.syscolumns a left outer join  sys.extended_properties  d on a.id = d.major_id and a.colid = d.minor_id and d.name = 'MS_Description' left outer join  sys.sysindexes b on a.id = b.id and ( b.status &amp; 0x800) = 0x800 left outer join sys.syscomments c on a.cdefault = c.id where object_name(a.id) = '"+row["TABLE_NAME"].ToString()+"' and a.status&lt;&gt;128  order by a.colorder";
        SqlCommand cmd1 = new SqlCommand(files, conn);
        SqlDataAdapter adFiles = new SqlDataAdapter(cmd1);
        DataSet dsFiles = new DataSet();
        adFiles.Fill(dsFiles);
        PopIndent();
        #&gt;
	}
}
    
&lt;#
        manager.EndBlock();    
         }            
        conn.Close();  
       manager.Process(true);  
        #&gt;</value>
    <comment>${SLN}$\${NR}$.Models\Models.tt</comment>
  </data>
  <data name="Models_packages_config" xml:space="preserve">
    <value>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;packages&gt;
  &lt;package id="AutoMapper" version="5.0.2" targetFramework="net461" /&gt;
  &lt;package id="AutoMapper.Attributes" version="6.0.1" targetFramework="net461" /&gt;
  &lt;package id="Dapper" version="2.0.123" targetFramework="net461" /&gt;
  &lt;package id="Dapper.Contrib" version="2.0.78" targetFramework="net461" /&gt;
  &lt;package id="Newtonsoft.Json" version="13.0.1" targetFramework="net461" /&gt;
&lt;/packages&gt;</value>
    <comment>${SLN}$\${NR}$.Models\packages.config</comment>
  </data>
  <data name="Repositories_Base_BaseRepository_cs" xml:space="preserve">
    <value>using Dapper;
using ${NR}$.Framework;
using ${NR}$.Models;
using System;
using System.Collections.Generic;
using System.Configuration;
using System.Data;
using System.Data.Common;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text.RegularExpressions;
using System.Threading;
using System.Transactions;
using System.Web;
using static Dapper.SqlMapper;

namespace ${NR}$.Repositories
{
    public class BaseRepository : IRepository
    {
        protected const string DEFAULTUSERID = "timetrackpro";
        protected const string DEFAULTPASSWORD = "tp2000";

        protected string ProviderName { get; set; }
        protected string ConnectionString { get; set; }

        public BaseRepository() : this(ConfigurationManager.AppSettings.Get("DefaultConnection"))
        {

        }

        public BaseRepository(string name)
        {
            ConnectionStringSettings settings;
            if (string.IsNullOrWhiteSpace(name))
                settings = ConfigurationManager.ConnectionStrings[ConfigurationManager.ConnectionStrings.Count - 1];
            else
                settings = ConfigurationManager.ConnectionStrings[name];
            ProviderName = settings.ProviderName;
            ConnectionString = settings.ConnectionString;
        }

        public DbProviderFactory GetProviderFactory()
        {
            return DbProviderFactories.GetFactory(ProviderName);
        }

        public DbConnection CreateConnection()
        {
            DbProviderFactory factory = GetProviderFactory();
            DbConnection conn = factory.CreateConnection();
            conn.ConnectionString = Regex.Replace(Regex.Replace(ConnectionString, nameof(DEFAULTUSERID), DEFAULTUSERID, RegexOptions.IgnoreCase), nameof(DEFAULTPASSWORD), DEFAULTPASSWORD, RegexOptions.IgnoreCase);
            return conn;
        }

        public IDisposable UseConnection(out IDbConnection conn)
        {
            ConnectionHolder holder = new ConnectionHolder(CreateConnection);
            conn = holder.Connection;
            return holder;
        }

        public dynamic GetOne(string sql, object param = null)
        {
            using (UseConnection(out IDbConnection conn))
            {
                return conn.QueryFirstOrDefault(sql, param);
            }
        }

        public T GetOne&lt;T&gt;(string sql, object param = null)
        {
            using (UseConnection(out IDbConnection conn))
            {
                return conn.QueryFirstOrDefault&lt;T&gt;(sql, param);
            }
        }

        public bool ExistsTable(string tableName)
        {
            return GetOne&lt;int?&gt;("select 1 from INFORMATION_SCHEMA.TABLES where TABLE_NAME=@tableName", new { tableName }) == 1;
        }

        public List&lt;dynamic&gt; Query(string sql, object param = null)
        {
            using (UseConnection(out IDbConnection conn))
            {
                return conn.Query(sql, param).ToList();
            }
        }

        public List&lt;T&gt; Query&lt;T&gt;(string sql, object param = null)
        {
            using (UseConnection(out IDbConnection conn))
            {
                return conn.Query&lt;T&gt;(sql, param).ToList();
            }
        }

        public PaggedOutput&lt;T&gt; QueryPagged&lt;T&gt;(string sql, object param, string orderBy, int pageNum = 1, int pageSize = 10)
        {
            int begin = (pageNum - 1) * pageSize + 1;
            int end = pageNum * pageSize;
            string commandText = $@"
SELECT *
     , ROW_NUMBER() OVER (ORDER BY {orderBy}) __ROW
  INTO #__TEMP
  FROM (
      {sql}
  ) __TEMP;

SELECT COUNT(1) total
  FROM #__TEMP;

SELECT *
  FROM #__TEMP
 WHERE __ROW BETWEEN {begin} AND {end};
";
            PaggedOutput&lt;T&gt; output = new PaggedOutput&lt;T&gt;();
            using (UseConnection(out IDbConnection conn))
            using (GridReader reader = conn.QueryMultiple(commandText, param))
            {
                output.Total = reader.ReadFirst&lt;int&gt;();
                output.Rows = reader.Read&lt;T&gt;().ToList();
            }
            return output;
        }

        public int Execute(string sql, object param = null)
        {
            using (UseConnection(out IDbConnection conn))
            {
                return conn.Execute(sql, param);
            }
        }
    }
}</value>
    <comment>${SLN}$\${NR}$.Repositories\Base\BaseRepository.cs</comment>
  </data>
  <data name="Repositories_Base_BaseRepository_1_cs" xml:space="preserve">
    <value>using Dapper;
using Dapper.Contrib;
using Dapper.Contrib.Extensions;
using ${NR}$.Framework;
using ${NR}$.Models;
using System;
using System.Collections.Generic;
using System.Configuration;
using System.Data;
using System.Data.Common;
using System.Dynamic;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Text.RegularExpressions;
using System.Transactions;
using System.Web;

namespace ${NR}$.Repositories
{
    public class BaseRepository&lt;T&gt; : BaseRepository, IRepository&lt;T&gt; where T : class
    {
        private static string _tableName;

        static BaseRepository()
        {
            SqlMapperExtensions.TableNameMapper = TableNameMapper.Instance.Get;
            ExpressionVisitor&lt;T&gt;.TableNameMapper = TableNameMapper.Instance.Get;
        }

        public static string TableName =&gt; _tableName ?? (_tableName = TableNameMapper.Instance.Get(typeof(T)));

        public BaseRepository() : base()
        {

        }

        public BaseRepository(string name) : base(name)
        {

        }

        public virtual long Insert(T entity)
        {
            if (entity is IAuditModel audit)
            {
                if (!string.IsNullOrWhiteSpace(CurrentUser.LoginId))
                {
                    audit.CreateDate = DateTime.Now;
                    audit.CreateUser = CurrentUser.LoginId;
                }
            }
            using (UseConnection(out IDbConnection conn))
            {
                long num = conn.Insert(entity);
                if (entity is IIdentityModel identity)
                {
                    return identity.ID = (int)num;
                }
                if (entity is IIdentityModel&lt;long&gt; longId)
                {
                    return longId.ID = num;
                }
                return num;
            }
        }

        public virtual bool Update(T entity)
        {
            if (entity is IAuditModel audit)
            {
                if (!string.IsNullOrWhiteSpace(CurrentUser.LoginId))
                {
                    audit.LastUpdateDate = DateTime.Now;
                    audit.LastUpdateUser = CurrentUser.LoginId;
                }
            }
            using (UseConnection(out IDbConnection conn))
            {
                return conn.Update(entity);
            }
        }

        public virtual bool Delete(T entity)
        {
            using (UseConnection(out IDbConnection conn))
            {
                return conn.Delete(entity);
            }
        }

        public virtual bool Delete(dynamic id)
        {
            string sql = $"DELETE FROM {TableName} WHERE ID=@ID";
            using (UseConnection(out IDbConnection conn))
            {
                return conn.Execute(sql, new { ID = id }) &gt; 0;
            }
        }

        public virtual T Get(dynamic id)
        {
            using (UseConnection(out IDbConnection conn))
            {
                return SqlMapperExtensions.Get&lt;T&gt;(conn, id);
            }
        }

        public virtual List&lt;T&gt; GetAll()
        {
            string sql = $"SELECT * FROM {TableName}";
            return Query&lt;T&gt;(sql);
        }

        public virtual new T GetOne(string sql, object param = null)
        {
            return GetOne&lt;T&gt;(sql, param);
        }

        public virtual new List&lt;T&gt; Query(string sql, object param = null)
        {
            return Query&lt;T&gt;(sql, param);
        }

        public virtual List&lt;T&gt; Find(object param)
        {
            var cols = ParamNameMapper.Instance.Get(param);
            string sql = $"SELECT * FROM {TableName} WHERE " + string.Join(" AND ", cols.Select(x =&gt; $"{x}=@{x}"));
            return Query&lt;T&gt;(sql, param);
        }

        public virtual T GetOne(Expression&lt;Func&lt;T, bool&gt;&gt; expression)
        {
            var visitor = new ExpressionVisitor&lt;T&gt;(expression);
            return GetOne&lt;T&gt;(visitor.ToString(), visitor.Parameters);
        }

        public virtual List&lt;T&gt; Query(Expression&lt;Func&lt;T, bool&gt;&gt; expression)
        {
            var visitor = new ExpressionVisitor&lt;T&gt;(expression);
            return Query&lt;T&gt;(visitor.ToString(), visitor.Parameters);
        }

        public virtual bool Exists(Expression&lt;Func&lt;T, bool&gt;&gt; expression)
        {
            var visitor = new ExpressionVisitor&lt;T&gt;(expression);
            string sql = $"SELECT 1 FROM {TableName} {visitor.Where}";
            return GetOne&lt;int?&gt;(sql, visitor.Parameters) == 1;
        }
    }
}</value>
    <comment>${SLN}$\${NR}$.Repositories\Base\BaseRepository`1.cs</comment>
  </data>
  <data name="Repositories_Base_ConnectionHolder_cs" xml:space="preserve">
    <value>using System;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Transactions;
using static Dapper.SqlMapper;

namespace ${NR}$.Repositories
{
    public class ConnectionHolder : IDisposable
    {
        private static readonly Dictionary&lt;string, IDbConnection&gt; _transactionConncetionPool = new Dictionary&lt;string, IDbConnection&gt;();

        private readonly Func&lt;IDbConnection&gt; _connectionCreater;
        private readonly bool _transient;

        public IDbConnection Connection { get; private set; }

        public ConnectionHolder(Func&lt;IDbConnection&gt; connectionCreater)
        {
            _connectionCreater = connectionCreater;
            if (Transaction.Current != null)
            {
                string id = Transaction.Current.TransactionInformation.LocalIdentifier;
                lock (_transactionConncetionPool)
                {
                    if (!_transactionConncetionPool.ContainsKey(id) || _transactionConncetionPool[id] == null)
                    {
                        _transactionConncetionPool[id] = _connectionCreater();
                        Transaction.Current.TransactionCompleted += Current_TransactionCompleted; ;
                    }
                    Connection = _transactionConncetionPool[id];
                    if (Connection.State == ConnectionState.Closed)
                    {
                        Connection.Open();
                    }
                }
                _transient = false;
            }
            else
            {
                Connection = _connectionCreater();
                Connection.Open();
                _transient = true;
            }
        }

        private void Current_TransactionCompleted(object sender, TransactionEventArgs e)
        {
            string id = e.Transaction.TransactionInformation.LocalIdentifier;
            lock (_transactionConncetionPool)
            {
                if (_transactionConncetionPool.ContainsKey(id))
                {
                    _transactionConncetionPool[id]?.Dispose();
                    _transactionConncetionPool.Remove(id);
                }
            }
        }

        public void Dispose()
        {
            if (_transient)
            {
                if (Connection != null)
                {
                    Connection.Dispose();
                    Connection = null;
                }
            }
        }
    }
}</value>
    <comment>${SLN}$\${NR}$.Repositories\Base\ConnectionHolder.cs</comment>
  </data>
  <data name="Repositories_Base_ExpressionVisitor_1_cs" xml:space="preserve">
    <value>using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Data.Common;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;
using System.Dynamic;

namespace ${NR}$.Repositories
{
    public class ExpressionVisitor&lt;TEntity&gt; : ExpressionVisitor
    {
        public delegate string TableNameMapperDelegate(Type type);

        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        public static TableNameMapperDelegate TableNameMapper;

        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private readonly List&lt;string&gt; _groupBy = new List&lt;string&gt;();

        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private readonly List&lt;string&gt; _orderBy = new List&lt;string&gt;();

        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private readonly IDictionary&lt;string, object&gt; _parameters = new ExpandoObject();

        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private readonly List&lt;string&gt; _select = new List&lt;string&gt;();

        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private readonly List&lt;string&gt; _update = new List&lt;string&gt;();

        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private readonly List&lt;string&gt; _where = new List&lt;string&gt;();

        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private int? _skip;

        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private int? _take;

        public ExpressionVisitor(Expression expression)
        {
            Visit(expression);
            TableName = TableNameMapper?.Invoke(typeof(TEntity)) ?? typeof(TEntity).Name;
        }

        public string CommandText =&gt; string.Join(Environment.NewLine, BuildSqlStatement());

        public string From =&gt; $" FROM {TableName}";
        public string GroupBy =&gt; _groupBy.Count == 0 ? null : " GROUP BY " + string.Join(", ", _groupBy);
        public bool IsDelete { get; private set; } = false;
        public bool IsDistinct { get; private set; }
        public string OrderBy =&gt; string.Join(" ", BuildOrderByStatement());
        public object Parameters =&gt; _parameters;
        public string Select =&gt; string.Join(" ", BuildSelectStatement());
        public int? Skip =&gt; _skip;
        public string TableName { get; private set; }
        public int? Take =&gt; _take;
        public string Update =&gt; " SET " + string.Join(", ", _update);
        public string Where =&gt; _where.Count == 0 ? null : " WHERE " + string.Join(" ", _where);

        public static implicit operator string(ExpressionVisitor&lt;TEntity&gt; visitor) =&gt; visitor.ToString();

        public override string ToString() =&gt; string.Join(Environment.NewLine, BuildSqlStatement());

        protected override Expression VisitBinary(BinaryExpression binaryExpression)
        {
            _where.Add("(");
            Visit(binaryExpression.Left);

            switch (binaryExpression.NodeType)
            {
                case ExpressionType.And:
                    _where.Add("AND");
                    break;

                case ExpressionType.AndAlso:
                    _where.Add("AND");
                    break;

                case ExpressionType.Or:
                case ExpressionType.OrElse:
                    _where.Add("OR");
                    break;

                case ExpressionType.Equal:
                    if (IsNullConstant(binaryExpression.Right))
                    {
                        _where.Add("IS");
                    }
                    else
                    {
                        _where.Add("=");
                    }
                    break;

                case ExpressionType.NotEqual:
                    if (IsNullConstant(binaryExpression.Right))
                    {
                        _where.Add("IS NOT");
                    }
                    else
                    {
                        _where.Add("&lt;&gt;");
                    }
                    break;

                case ExpressionType.LessThan:
                    _where.Add("&lt;");
                    break;

                case ExpressionType.LessThanOrEqual:
                    _where.Add("&lt;=");
                    break;

                case ExpressionType.GreaterThan:
                    _where.Add("&gt;");
                    break;

                case ExpressionType.GreaterThanOrEqual:
                    _where.Add("&gt;=");
                    break;

                default:
                    throw new NotSupportedException($"The binary operator '{binaryExpression.NodeType}' is not supported");
            }

            Visit(binaryExpression.Right);
            _where.Add(")");
            return binaryExpression;
        }

        protected override Expression VisitConstant(ConstantExpression constantExpression)
        {
            switch (constantExpression.Value)
            {
                case null when constantExpression.Value == null:
                    _where.Add("NULL");
                    break;

                default:
                    _where.Add(CreateParameter(constantExpression.Value));
                    break;
            }
            return constantExpression;
        }

        protected override Expression VisitMember(MemberExpression memberExpression)
        {
            Expression VisitMemberLocal(Expression expression)
            {
                switch (expression.NodeType)
                {
                    case ExpressionType.Parameter:
                        _where.Add($"{memberExpression.Member.Name}");
                        return memberExpression;

                    case ExpressionType.Constant:
                        _where.Add(CreateParameter(GetValue(memberExpression), memberExpression.Member));
                        return memberExpression;

                    case ExpressionType.MemberAccess:
                        _where.Add(CreateParameter(GetValue(memberExpression), memberExpression.Member));
                        return memberExpression;
                }

                throw new NotSupportedException($"The member '{memberExpression.Member.Name}' is not supported");
            }
            if (memberExpression.Expression == null)
            {
                return VisitMemberLocal(memberExpression);
            }
            return VisitMemberLocal(memberExpression.Expression);
        }

        protected override Expression VisitMethodCall(MethodCallExpression methodCallExpression)
        {
            switch (methodCallExpression.Method.Name)
            {
                case nameof(Queryable.Where) when methodCallExpression.Method.DeclaringType == typeof(Queryable):
                    Visit(methodCallExpression.Arguments[0]);
                    var lambda = (LambdaExpression)StripQuotes(methodCallExpression.Arguments[1]);
                    Visit(lambda.Body);
                    return methodCallExpression;

                case nameof(Queryable.Select):
                    return ParseExpression(methodCallExpression, _select);

                case nameof(Queryable.GroupBy):
                    return ParseExpression(methodCallExpression, _groupBy);

                case nameof(Queryable.Take):
                    return ParseExpression(methodCallExpression, ref _take);

                case nameof(Queryable.Skip):
                    return ParseExpression(methodCallExpression, ref _skip);

                case nameof(Queryable.OrderBy):
                case nameof(Queryable.ThenBy):
                    return ParseExpression(methodCallExpression, _orderBy, "ASC");

                case nameof(Queryable.OrderByDescending):
                case nameof(Queryable.ThenByDescending):
                    return ParseExpression(methodCallExpression, _orderBy, "DESC");

                case nameof(Queryable.Distinct):
                    IsDistinct = true;
                    return Visit(methodCallExpression.Arguments[0]);

                case nameof(string.StartsWith):
                    _where.AddRange(ParseExpression(methodCallExpression, methodCallExpression.Object));
                    _where.Add("LIKE");
                    _where.Add(CreateParameter(GetValue(methodCallExpression.Arguments[0]).ToString() + "%"));
                    return methodCallExpression.Arguments[0];

                case nameof(string.EndsWith):
                    _where.AddRange(ParseExpression(methodCallExpression, methodCallExpression.Object));
                    _where.Add("LIKE");
                    _where.Add(CreateParameter("%" + GetValue(methodCallExpression.Arguments[0]).ToString()));
                    return methodCallExpression.Arguments[0];

                case nameof(string.Contains):
                    _where.AddRange(ParseExpression(methodCallExpression, methodCallExpression.Object));
                    _where.Add("LIKE");
                    _where.Add(CreateParameter("%" + GetValue(methodCallExpression.Arguments[0]).ToString() + "%"));
                    return methodCallExpression.Arguments[0];

                case "ToSqlString"/*nameof(Extensions.ToSqlString)*/:
                    return Visit(methodCallExpression.Arguments[0]);

                case "Delete"/*nameof(Extensions.Delete)*/:
                case "DeleteAsync"/*nameof(Extensions.DeleteAsync)*/:
                    IsDelete = true;
                    return Visit(methodCallExpression.Arguments[0]);

                case "Update"/*nameof(Extensions.Update)*/:
                    return ParseExpression(methodCallExpression, _update);

                default:
                    if (methodCallExpression.Object != null)
                    {
                        _where.Add(CreateParameter(GetValue(methodCallExpression)));
                        return methodCallExpression;
                    }
                    break;
            }

            throw new NotSupportedException($"The method '{methodCallExpression.Method.Name}' is not supported");
        }

        protected override Expression VisitUnary(UnaryExpression unaryExpression)
        {
            switch (unaryExpression.NodeType)
            {
                case ExpressionType.Not:
                    _where.Add("NOT");
                    Visit(unaryExpression.Operand);
                    break;
                case ExpressionType.Convert:
                    Visit(unaryExpression.Operand);
                    break;
                default:
                    throw new NotSupportedException($"The unary operator '{unaryExpression.NodeType}' is not supported");
            }
            return unaryExpression;
        }

        private static Expression StripQuotes(Expression expression)
        {
            while (expression.NodeType == ExpressionType.Quote)
            {
                expression = ((UnaryExpression)expression).Operand;
            }
            return expression;
        }


        //[SuppressMessage("Style", "IDE0011:Add braces", Justification = "Easier to read")]
        //private IEnumerable&lt;string&gt; BuildDeclaration()
        //{
        //    if (Parameters.Length == 0)                        /**/    yield break;
        //    foreach (DbParameter parameter in Parameters)     /**/    yield return $"DECLARE {parameter} {parameter.SqlDbType}";


        //    foreach (DbParameter parameter in Parameters)     /**/
        //        if (parameter.SqlDbType.RequiresQuotes())      /**/    yield return $"SET {parameter} = '{parameter.SqlValue?.ToString().Replace("'", "''") ?? "NULL"}'";
        //        else                                           /**/    yield return $"SET {parameter} = {parameter.SqlValue}";
        //}


        [SuppressMessage("Style", "IDE0011:Add braces", Justification = "Easier to read")]
        private IEnumerable&lt;string&gt; BuildOrderByStatement()
        {
            if (Skip.HasValue &amp;&amp; _orderBy.Count == 0)                       /**/   yield return "ORDER BY (SELECT NULL)";
            else if (_orderBy.Count == 0)                                   /**/   yield break;
            else if (_groupBy.Count &gt; 0 &amp;&amp; _orderBy[0].StartsWith("[Key]")) /**/   yield return "ORDER BY " + string.Join(", ", _groupBy);
            else                                                            /**/   yield return "ORDER BY " + string.Join(", ", _orderBy);

            if (Skip.HasValue &amp;&amp; Take.HasValue)                             /**/   yield return $"OFFSET {Skip} ROWS FETCH NEXT {Take} ROWS ONLY";
            else if (Skip.HasValue &amp;&amp; !Take.HasValue)                       /**/   yield return $"OFFSET {Skip} ROWS";
        }

        [SuppressMessage("Style", "IDE0011:Add braces", Justification = "Easier to read")]
        private IEnumerable&lt;string&gt; BuildSelectStatement()
        {
            yield return "SELECT";

            if (IsDistinct)                                 /**/    yield return "DISTINCT";

            if (Take.HasValue &amp;&amp; !Skip.HasValue)            /**/    yield return $"TOP ({Take.Value})";

            if (_select.Count == 0 &amp;&amp; _groupBy.Count &gt; 0)   /**/    yield return string.Join(", ", _groupBy.Select(x =&gt; $"MAX({x})"));
            else if (_select.Count == 0)                    /**/    yield return "*";
            else                                            /**/    yield return string.Join(", ", _select);
        }


        [SuppressMessage("Style", "IDE0011:Add braces", Justification = "Easier to read")]
        private IEnumerable&lt;string&gt; BuildSqlStatement()
        {
            if (IsDelete)                   /**/   yield return "DELETE";
            else if (_update.Count &gt; 0)     /**/   yield return $"UPDATE {TableName}";
            else                            /**/   yield return Select;

            if (_update.Count == 0)         /**/   yield return From;
            else if (_update.Count &gt; 0)     /**/   yield return Update;

            if (Where != null)              /**/   yield return Where;
            if (GroupBy != null)            /**/   yield return GroupBy;
            if (OrderBy != null)            /**/   yield return OrderBy;
        }


        private string CreateParameter(object value, MemberInfo member = null)
        {
            string parameterName = member == null ? $"@p{_parameters.Count + 1}" : $"@{member.Name}";

            _parameters[parameterName] = value;

            return parameterName;
        }

        private IEnumerable&lt;string&gt; GetNewExpressionString(NewExpression newExpression, string appendString = null)
        {
            for (int i = 0; i &lt; newExpression.Members.Count; i++)
            {
                if (newExpression.Arguments[i].NodeType == ExpressionType.MemberAccess)
                {
                    yield return
                        appendString == null ?
                        $"{newExpression.Members[i].Name}" :
                        $"{newExpression.Members[i].Name} {appendString}";
                }
                else
                {
                    yield return
                        appendString == null ?
                        $"{newExpression.Members[i].Name} = {CreateParameter(GetValue(newExpression.Arguments[i]), newExpression.Members[i])}" :
                        $"{newExpression.Members[i].Name} = {CreateParameter(GetValue(newExpression.Arguments[i]), newExpression.Members[i])}";
                }
            }
        }

        private object GetValue(Expression expression)
        {
            object GetMemberValue(MemberInfo memberInfo, object container = null)
            {
                switch (memberInfo)
                {
                    case FieldInfo fieldInfo:
                        return fieldInfo.GetValue(container);

                    case PropertyInfo propertyInfo:
                        return propertyInfo.GetValue(container);

                    default: return null;
                }
            }

            switch (expression)
            {
                case ConstantExpression constantExpression:
                    return constantExpression.Value;

                case MemberExpression memberExpression when memberExpression.Expression is MemberExpression innerMemberExpression:
                    return GetMemberValue(memberExpression.Member, GetValue(innerMemberExpression));

                case MemberExpression memberExpression when memberExpression.Expression is ConstantExpression constantExpression:
                    return GetMemberValue(memberExpression.Member, constantExpression.Value);

                case MemberExpression memberExpression when memberExpression.Expression is null: // static
                    return GetMemberValue(memberExpression.Member);

                case MethodCallExpression methodCallExpression:
                    return Expression.Lambda(methodCallExpression).Compile().DynamicInvoke();

                case null:
                    return null;
            }

            throw new NotSupportedException();
        }


        private bool IsNullConstant(Expression expression) =&gt; expression.NodeType == ExpressionType.Constant &amp;&amp; ((ConstantExpression)expression).Value == null;

        private IEnumerable&lt;string&gt; ParseExpression(Expression parent, Expression body, string appendString = null)
        {
            switch (body)
            {
                case MemberExpression memberExpression:
                    return appendString == null ?
                        new string[] { $"{memberExpression.Member.Name}" } :
                        new string[] { $"{memberExpression.Member.Name} {appendString}" };

                case NewExpression newExpression:
                    return GetNewExpressionString(newExpression, appendString);

                case ParameterExpression parameterExpression when parent is LambdaExpression lambdaExpression &amp;&amp; lambdaExpression.ReturnType == parameterExpression.Type:
                    return new string[0];

                case ConstantExpression constantExpression:
                    return constantExpression
                        .Type
                        .GetProperties(BindingFlags.Public | BindingFlags.Instance)
                        .Select(x =&gt; $"{x.Name} = {CreateParameter(x.GetValue(constantExpression.Value), x)}");
            }

            throw new NotSupportedException();
        }


        private Expression ParseExpression(MethodCallExpression expression, List&lt;string&gt; commandList, string appendString = null)
        {
            var unary = (UnaryExpression)expression.Arguments[1];
            var lambdaExpression = (LambdaExpression)unary.Operand;

            lambdaExpression = (LambdaExpression)Evaluator.PartialEval(lambdaExpression);

            commandList.AddRange(ParseExpression(lambdaExpression, lambdaExpression.Body, appendString));

            return Visit(expression.Arguments[0]);
        }


        private Expression ParseExpression(MethodCallExpression expression, ref int? size)
        {
            var sizeExpression = (ConstantExpression)expression.Arguments[1];

            if (int.TryParse(sizeExpression.Value.ToString(), out int value))
            {
                size = value;
                return Visit(expression.Arguments[0]);
            }

            throw new NotSupportedException();
        }

        /// &lt;summary&gt;
        /// Enables the partial evaluation of queries.
        /// &lt;/summary&gt;
        /// &lt;remarks&gt;
        /// From http://msdn.microsoft.com/en-us/library/bb546158.aspx
        /// Copyright notice http://msdn.microsoft.com/en-gb/cc300389.aspx#O
        /// &lt;/remarks&gt;
        static class Evaluator
        {
            /// &lt;summary&gt;
            /// Performs evaluation and replacement of independent sub-trees
            /// &lt;/summary&gt;
            /// &lt;param name="expression"&gt;The root of the expression tree.&lt;/param&gt;
            /// &lt;param name="fnCanBeEvaluated"&gt;A function that decides whether a given expression node can be part of the local function.&lt;/param&gt;
            /// &lt;returns&gt;A new tree with sub-trees evaluated and replaced.&lt;/returns&gt;
            public static Expression PartialEval(Expression expression, Func&lt;Expression, bool&gt; fnCanBeEvaluated)
            {
                return new SubtreeEvaluator(new Nominator(fnCanBeEvaluated).Nominate(expression)).Eval(expression);
            }

            /// &lt;summary&gt;
            /// Performs evaluation and replacement of independent sub-trees
            /// &lt;/summary&gt;
            /// &lt;param name="expression"&gt;The root of the expression tree.&lt;/param&gt;
            /// &lt;returns&gt;A new tree with sub-trees evaluated and replaced.&lt;/returns&gt;
            public static Expression PartialEval(Expression expression)
            {
                return PartialEval(expression, Evaluator.CanBeEvaluatedLocally);
            }

            private static bool CanBeEvaluatedLocally(Expression expression)
            {
                return expression.NodeType != ExpressionType.Parameter;
            }

            /// &lt;summary&gt;
            /// Evaluates and replaces sub-trees when first candidate is reached (top-down)
            /// &lt;/summary&gt;
            class SubtreeEvaluator : ExpressionVisitor
            {
                HashSet&lt;Expression&gt; candidates;

                internal SubtreeEvaluator(HashSet&lt;Expression&gt; candidates)
                {
                    this.candidates = candidates;
                }

                internal Expression Eval(Expression exp)
                {
                    return this.Visit(exp);
                }

                public override Expression Visit(Expression exp)
                {
                    if (exp == null)
                    {
                        return null;
                    }
                    if (this.candidates.Contains(exp))
                    {
                        return this.Evaluate(exp);
                    }
                    return base.Visit(exp);
                }

                private Expression Evaluate(Expression e)
                {
                    if (e.NodeType == ExpressionType.Constant)
                    {
                        return e;
                    }
                    LambdaExpression lambda = Expression.Lambda(e);
                    Delegate fn = lambda.Compile();
                    return Expression.Constant(fn.DynamicInvoke(null), e.Type);
                }

                protected override Expression VisitMemberInit(MemberInitExpression node)
                {
                    if (node.NewExpression.NodeType == ExpressionType.New)
                        return node;

                    return base.VisitMemberInit(node);
                }
            }

            /// &lt;summary&gt;
            /// Performs bottom-up analysis to determine which nodes can possibly
            /// be part of an evaluated sub-tree.
            /// &lt;/summary&gt;
            class Nominator : ExpressionVisitor
            {
                Func&lt;Expression, bool&gt; fnCanBeEvaluated;
                HashSet&lt;Expression&gt; candidates;
                bool cannotBeEvaluated;

                internal Nominator(Func&lt;Expression, bool&gt; fnCanBeEvaluated)
                {
                    this.fnCanBeEvaluated = fnCanBeEvaluated;
                }

                internal HashSet&lt;Expression&gt; Nominate(Expression expression)
                {
                    this.candidates = new HashSet&lt;Expression&gt;();
                    this.Visit(expression);
                    return this.candidates;
                }

                public override Expression Visit(Expression expression)
                {
                    if (expression != null)
                    {
                        bool saveCannotBeEvaluated = this.cannotBeEvaluated;
                        this.cannotBeEvaluated = false;
                        base.Visit(expression);
                        if (!this.cannotBeEvaluated)
                        {
                            if (this.fnCanBeEvaluated(expression))
                            {
                                this.candidates.Add(expression);
                            }
                            else
                            {
                                this.cannotBeEvaluated = true;
                            }
                        }
                        this.cannotBeEvaluated |= saveCannotBeEvaluated;
                    }
                    return expression;
                }
            }
        }
    }
}</value>
    <comment>${SLN}$\${NR}$.Repositories\Base\ExpressionVisitor`1.cs</comment>
  </data>
  <data name="Repositories_Base_IRepository_cs" xml:space="preserve">
    <value>using ${NR}$.Models;
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using static Dapper.SqlMapper;

namespace ${NR}$.Repositories
{
    public interface IRepository
    {
        DbProviderFactory GetProviderFactory();
        DbConnection CreateConnection();
        IDisposable UseConnection(out IDbConnection conn);
        dynamic GetOne(string sql, object param = null);
        T GetOne&lt;T&gt;(string sql, object param = null);
        List&lt;dynamic&gt; Query(string sql, object param = null);
        List&lt;T&gt; Query&lt;T&gt;(string sql, object param = null);
        PaggedOutput&lt;T&gt; QueryPagged&lt;T&gt;(string sql, object param, string orderBy, int pageNum = 1, int pageSize = 10);
        int Execute(string sql, object param = null);
    }
}</value>
    <comment>${SLN}$\${NR}$.Repositories\Base\IRepository.cs</comment>
  </data>
  <data name="Repositories_Base_IRepository_1_cs" xml:space="preserve">
    <value>using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Text;
using System.Threading.Tasks;

namespace ${NR}$.Repositories
{
    public interface IRepository&lt;T&gt; : IRepository
    {
        long Insert(T entity);
        bool Update(T entity);
        bool Delete(T entity);
        bool Delete(dynamic id);
        T Get(dynamic id);
        List&lt;T&gt; GetAll();
        new T GetOne(string sql, object param = null);
        new List&lt;T&gt; Query(string sql, object param = null);
        List&lt;T&gt; Find(object param);
        T GetOne(Expression&lt;Func&lt;T, bool&gt;&gt; expression);
        List&lt;T&gt; Query(Expression&lt;Func&lt;T, bool&gt;&gt; expression);
        bool Exists(Expression&lt;Func&lt;T, bool&gt;&gt; expression);
    }
}</value>
    <comment>${SLN}$\${NR}$.Repositories\Base\IRepository`1.cs</comment>
  </data>
  <data name="Repositories_Base_ParamNameMapper_cs" xml:space="preserve">
    <value>using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;

namespace ${NR}$.Repositories
{
    public class ParamNameMapper
    {
        private static readonly Lazy&lt;ParamNameMapper&gt; _lazy;
        private static readonly ConcurrentDictionary&lt;Guid, PropertyInfo[]&gt; _propsCache;

        static ParamNameMapper()
        {
            _lazy = new Lazy&lt;ParamNameMapper&gt;(() =&gt; new ParamNameMapper(), isThreadSafe: true);
            _propsCache = new ConcurrentDictionary&lt;Guid, PropertyInfo[]&gt;();
        }

        private ParamNameMapper() { }

        public static ParamNameMapper Instance =&gt; _lazy.Value;

        private PropertyInfo[] GetProperties(Type type)
        {
            Guid id = type.GUID;
            if (!_propsCache.ContainsKey(id))
            {
                _propsCache.TryAdd(id, type.GetProperties());
            }
            return _propsCache[id];
        }

        public IEnumerable&lt;string&gt; Get(object param)
        {
            PropertyInfo[] props = GetProperties(param.GetType());
            return props.Select(x =&gt; x.Name);
        }
    }
}</value>
    <comment>${SLN}$\${NR}$.Repositories\Base\ParamNameMapper.cs</comment>
  </data>
  <data name="Repositories_Base_TableNameMapper_cs" xml:space="preserve">
    <value>using ${NR}$.Models;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ${NR}$.Repositories
{
    public class TableNameMapper
    {
        private static readonly Lazy&lt;TableNameMapper&gt; _lazy;
        private static readonly ConcurrentDictionary&lt;Type, string&gt; _tableNameCache;

        static TableNameMapper()
        {
            _lazy = new Lazy&lt;TableNameMapper&gt;(() =&gt; new TableNameMapper(), isThreadSafe: true);
            _tableNameCache = new ConcurrentDictionary&lt;Type, string&gt;();
        }

        private TableNameMapper() { }

        public static TableNameMapper Instance =&gt; _lazy.Value;

        public string Get(Type type)
        {
            if (!_tableNameCache.ContainsKey(type))
            {
                _tableNameCache.TryAdd(type, GetTableName(type));
            }
            return _tableNameCache[type];
        }

        private static string GetTableName(Type type)
        {
            DateTime now = DateTime.Now;
            string tableName = type.Name;
            if (tableName.Contains("YYYY"))
                tableName = tableName.Replace("YYYY", now.Year.ToString("0000"));
            if (tableName.Contains("MM"))
                tableName = tableName.Replace("MM", now.Month.ToString("00"));
            return tableName;
        }
    }
}</value>
    <comment>${SLN}$\${NR}$.Repositories\Base\TableNameMapper.cs</comment>
  </data>
  <data name="Framework_Clock_ClockDaemon_cs" xml:space="preserve">
    <value>using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;

namespace Clock
{
    public interface IClockDaemon
    {
        void Clear();
        void Add(string schedule, Action action);
        void Start();
        void Stop(bool clearJobs = true, int timeout = 3 * 60 * 1000);
    }
    public class ClockDaemon : IClockDaemon
    {
        private CancellationTokenSource _cancellationTokenSource;
        private Task _manager;
        private readonly List&lt;IClockJob&gt; _clockjobs = new List&lt;IClockJob&gt;();
        private DateTime _last = DateTime.Now;

        public ClockDaemon()
        {
            _cancellationTokenSource = new CancellationTokenSource();
        }

        public void Clear()
        {
            _clockjobs.Clear();
        }

        public void Add(string schedule, Action action)
        {
            _clockjobs.Add(new ClockJob(schedule, action));
        }

        public void Start()
        {
            _manager = new Task(Run, _cancellationTokenSource.Token, TaskCreationOptions.LongRunning);
            _manager.ContinueWith(t =&gt; t.Dispose());
            _manager.Start();
        }

        public void Stop(bool clearJobs = true, int timeout = 3 * 60 * 1000)
        {
            _cancellationTokenSource.Cancel();
            _cancellationTokenSource = new CancellationTokenSource();
            //foreach (var job in _clockjobs) job.Cancel();
            Parallel.ForEach(_clockjobs, x =&gt; x.WaitStop(timeout));
            if (clearJobs) Clear();
        }

        private void Run()
        {
            while (true)
            {
                if (DateTime.Now.Minute != _last.Minute)
                {
                    _last = DateTime.Now;
                    foreach (IClockJob job in _clockjobs)
                        job.Run(DateTime.Now);
                }
                Task.Delay(5000).Wait();
            }
        }
    }
}</value>
    <comment>${SLN}$\${NR}$.Framework\Clock\ClockDaemon.cs</comment>
  </data>
  <data name="Repositories_Properties_AssemblyInfo_cs" xml:space="preserve">
    <value>using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// 有关程序集的一般信息由以下
// 控制。更改这些特性值可修改
// 与程序集关联的信息。
[assembly: AssemblyTitle("${NR}$.Repositoies")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("${NR}$.Repositoies")]
[assembly: AssemblyCopyright("Copyright ©  2022")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// 将 ComVisible 设置为 false 会使此程序集中的类型
//对 COM 组件不可见。如果需要从 COM 访问此程序集中的类型
//请将此类型的 ComVisible 特性设置为 true。
[assembly: ComVisible(false)]

// 如果此项目向 COM 公开，则下列 GUID 用于类型库的 ID
[assembly: Guid("${RepositoriesProjectGuid}$")]

// 程序集的版本信息由下列四个值组成: 
//
//      主版本
//      次版本
//      生成号
//      修订号
//
// 可以指定所有值，也可以使用以下所示的 "*" 预置版本号和修订号
//通过使用 "*"，如下所示:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]</value>
    <comment>${SLN}$\${NR}$.Repositories\Properties\AssemblyInfo.cs</comment>
  </data>
  <data name="Repositories_app_config" xml:space="preserve">
    <value>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;configuration&gt;
  &lt;runtime&gt;
    &lt;assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1"&gt;
      &lt;dependentAssembly&gt;
        &lt;assemblyIdentity name="System.Threading.Tasks.Extensions" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" /&gt;
        &lt;bindingRedirect oldVersion="0.0.0.0-4.2.0.1" newVersion="4.2.0.1" /&gt;
      &lt;/dependentAssembly&gt;
    &lt;/assemblyBinding&gt;
  &lt;/runtime&gt;
&lt;/configuration&gt;</value>
    <comment>${SLN}$\${NR}$.Repositories\app.config</comment>
  </data>
  <data name="Repositories_packages_config" xml:space="preserve">
    <value>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;packages&gt;
  &lt;package id="Dapper" version="2.0.123" targetFramework="net461" /&gt;
  &lt;package id="Dapper.Contrib" version="2.0.78" targetFramework="net461" /&gt;
&lt;/packages&gt;</value>
    <comment>${SLN}$\${NR}$.Repositories\packages.config</comment>
  </data>
  <data name="Services_Base_BaseService_cs" xml:space="preserve">
    <value>using System;

namespace ${NR}$.Services
{
    public class BaseService : IService
    {
    }
}</value>
    <comment>${SLN}$\${NR}$.Services\Base\BaseService.cs</comment>
  </data>
  <data name="Services_Base_IService_cs" xml:space="preserve">
    <value>using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ${NR}$.Services
{
    public interface IService
    {
    }
}</value>
    <comment>${SLN}$\${NR}$.Services\Base\IService.cs</comment>
  </data>
  <data name="Services_Properties_AssemblyInfo_cs" xml:space="preserve">
    <value>using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// 有关程序集的一般信息由以下
// 控制。更改这些特性值可修改
// 与程序集关联的信息。
[assembly: AssemblyTitle("${NR}$.Services")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("${NR}$.Services")]
[assembly: AssemblyCopyright("Copyright ©  2022")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// 将 ComVisible 设置为 false 会使此程序集中的类型
//对 COM 组件不可见。如果需要从 COM 访问此程序集中的类型
//请将此类型的 ComVisible 特性设置为 true。
[assembly: ComVisible(false)]

// 如果此项目向 COM 公开，则下列 GUID 用于类型库的 ID
[assembly: Guid("${ServicesProjectGuid}$")]

// 程序集的版本信息由下列四个值组成: 
//
//      主版本
//      次版本
//      生成号
//      修订号
//
// 可以指定所有值，也可以使用以下所示的 "*" 预置版本号和修订号
//通过使用 "*"，如下所示:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]</value>
    <comment>${SLN}$\${NR}$.Services\Properties\AssemblyInfo.cs</comment>
  </data>
  <data name="Debug_Properties_AssemblyInfo_cs" xml:space="preserve">
    <value>using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// 有关程序集的一般信息由以下
// 控制。更改这些特性值可修改
// 与程序集关联的信息。
[assembly: AssemblyTitle("${NR}$.Debug")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("${NR}$.Debug")]
[assembly: AssemblyCopyright("Copyright ©  2022")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// 将 ComVisible 设置为 false 会使此程序集中的类型
//对 COM 组件不可见。如果需要从 COM 访问此程序集中的类型
//请将此类型的 ComVisible 特性设置为 true。
[assembly: ComVisible(false)]

// 如果此项目向 COM 公开，则下列 GUID 用于类型库的 ID
[assembly: Guid("${DebugProjectGuid}$")]

// 程序集的版本信息由下列四个值组成: 
//
//      主版本
//      次版本
//      生成号
//      修订号
//
// 可以指定所有值，也可以使用以下所示的 "*" 预置版本号和修订号
// 方法是按如下所示使用“*”: :
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]</value>
    <comment>${SLN}$\${NR}$.Debug\Properties\AssemblyInfo.cs</comment>
  </data>
  <data name="Debug_App_config" xml:space="preserve">
    <value>&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;configuration&gt;
  &lt;connectionStrings&gt;
    &lt;add name="conn" connectionString="${CONN}$" providerName="System.Data.SqlClient" /&gt;
  &lt;/connectionStrings&gt;
  &lt;startup&gt;
    &lt;supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.6.1" /&gt;
  &lt;/startup&gt;
&lt;/configuration&gt;</value>
    <comment>${SLN}$\${NR}$.Debug\App.config</comment>
  </data>
  <data name="Debug_Program_cs" xml:space="preserve">
    <value>using ${NR}$.Framework;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ${NR}$.Debug
{
    class Program
    {
        static void Main(string[] args)
        {
            AppDomain.CurrentDomain.UnhandledException += new UnhandledExceptionEventHandler(CurrentDomain_UnhandledException);
            CurrentUser.LoginId = "admin";
            Logger.Info("Startup.");
        }

        static void CurrentDomain_UnhandledException(object sender, UnhandledExceptionEventArgs e)
        {
            string path = System.IO.Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "UnhandledException", $"{DateTime.Now:yyyyMMdd_HHmmss}.txt");
            System.IO.File.WriteAllText(path, e.ExceptionObject.ToString());
        }
    }
}</value>
    <comment>${SLN}$\${NR}$.Debug\Program.cs</comment>
  </data>
  <data name="Framework_Clock_ClockJob_cs" xml:space="preserve">
    <value>using System;
using System.Threading;
using System.Threading.Tasks;

namespace Clock
{
    public interface IClockJob
    {
        void Run(DateTime date_time);
        void Cancel();
        void WaitStop(int timeout = 3 * 60 * 1000);
    }

    public class ClockJob : IClockJob
    {
        private readonly IClockSchedule _clockSchedule = new ClockSchedule();
        private readonly Action _action;
        private readonly object _lock = new object();
        private CancellationTokenSource _cancellationTokenSource;
        private Task _task;

        public ClockJob(string schedule, Action action)
        {
            _clockSchedule = new ClockSchedule(schedule);
            _action = action;
            _cancellationTokenSource = new CancellationTokenSource();
            _task = new Task(action, _cancellationTokenSource.Token, TaskCreationOptions.LongRunning);
        }

        public void Run(DateTime dateTime)
        {
            lock (_lock)
            {
                if (_clockSchedule.IsTime(dateTime) &amp;&amp; _task.Status != TaskStatus.Running)
                {
                    _task = new Task(_action, _cancellationTokenSource.Token, TaskCreationOptions.LongRunning);
                    _task.Start();
                }
            }
        }

        public void Cancel()
        {
            _cancellationTokenSource.Cancel();
            _cancellationTokenSource = new CancellationTokenSource();
        }

        public void WaitStop(int timeout = 3 * 60 * 1000)
        {
            const int step = 200;
            int waiting = 0;
            while (!_task.IsCompleted &amp;&amp; waiting &lt; timeout)
            {
                Thread.Sleep(step);
                waiting += step;
            }
            Cancel();
            _task.Dispose();
        }
    }
}</value>
    <comment>${SLN}$\${NR}$.Framework\Clock\ClockJob.cs</comment>
  </data>
  <data name="Framework_Clock_ClockSchedule_cs" xml:space="preserve">
    <value>using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;

namespace Clock
{
    public interface IClockSchedule
    {
        bool IsTime(DateTime date_time);
    }

    public class ClockSchedule : IClockSchedule
    {
        private readonly string _expression;
        public List&lt;TimeSpan&gt; Times;

        public ClockSchedule()
        {
        }

        public ClockSchedule(string expressions)
        {
            _expression = expressions.Trim();
            Times = expressions.Split(new[] { ',', ';', '|', '，', '；', '、' }).Select(ToTimeSpan).OrderBy(x =&gt; x).ToList();
        }

        public TimeSpan ToTimeSpan(string time)
        {
            int h = 0, m = 0, s = 0;
            var arr = time.Split(':');
            if (arr.Length &gt; 1)
            {
                h = Convert.ToInt32(arr[0]);
                m = Convert.ToInt32(arr[1]);
                if (arr.Length &gt; 2)
                {
                    s = Convert.ToInt32(arr[2]);
                }
            }
            return new TimeSpan(h, m, s);
        }

        public bool IsTime(DateTime date_time)
        {
            if (_expression == "*") return true;
            return Times.Any(x =&gt; x.Hours == date_time.Hour &amp;&amp; x.Minutes == date_time.Minute);
        }

        public DateTime NextRun(DateTime? fromDate = null)
        {
            var date = fromDate ?? DateTime.Now;
            date = date.AddSeconds(60 - date.Second);
            while (!IsTime(date))
            {
                date = date.AddMinutes(1);
            }
            return date;
        }

        public DateTime LastRun(DateTime? fromDate = null)
        {
            var date = fromDate ?? DateTime.Now;
            date = date.AddSeconds(-date.Second);
            while (!IsTime(date))
            {
                date = date.AddMinutes(-1);
            }
            return date;
        }
    }
}</value>
    <comment>${SLN}$\${NR}$.Framework\Clock\ClockSchedule.cs</comment>
  </data>
</root>